= Язык "Серебро" (Argentum)

== Инициализация фреймворка

[init]

	use common::sense;
	use lib "lib";
	use R::App qw/$app msg msg1/;
	
	$app->man->conf;
	
[test]


== Скаляры - строки и цифры

	$app->syntaxAg->new->eval("1");							# 1
	$app->syntaxAg->new->eval("1.1");						# 1.1
	$app->syntaxAg->new->eval("7_007_001_11_11");			# 70070011111
	$app->syntaxAg->new->eval("7_007_001_11_11.7_007");		# 70070011111.7007
	$app->syntaxAg->new->eval("-10");						# -10
	$app->syntaxAg->new->eval("0xFF");						# 255
	$app->syntaxAg->new->eval("0b10");						# 2
	$app->syntaxAg->new->eval("3r10");						# 3
	
	$app->syntaxAg->new->eval('"строка в utf8"');							# строка в utf8
	
Строки поддерживают интерполяцию:
	
	$app->syntaxAg->new->eval('utf8 = "utf8"; "строка в $utf8"');					# строка в utf8
	$app->syntaxAg->new->eval('hash = {key=>"utf8"}; "строка в $hash:key"');		# строка в utf8
	#$app->syntaxAg->new->eval('hash = {a=>6}; "строка в $a:6"');					# строка в utf8

== Классы и методы

=== Проект

Проект, это папка в которой лежит `Aquafile`.
Файлы с расширением `.ag` - классы на `Серебряне`.

Файлы в подпапках - это классы.
Компилляция просходит в подпапку `.Aqua` проекта.

*/myproject*
* _ .Aqua
* _ Aquafile

	my $dir = $app->file("var/_test_13_ag")->rm->mkdir;
	my $file = $dir->sub("/Tess.ag");
	
	$app->syntaxAg->ag($file->path);		#@ ~ файл находится не в проекте.* создайте Aquafile
	
Создадим *Aquafile*:
	
	my $Aquafile = $dir->sub("/Aquafile")->write("");
	
	$app->syntaxAg->ag($file->path);		#@ ~ нет “Tess.ag”

Компиляция исходников происходит в поддиректорию `.Aqua`. Причём первым компилируется *Aquafile*.

	$app->file("var/_test_13_ag/.Aqua/Aquafile.pm")->exists;		# 1

Если файл не начинается на `class name`, где `name` - имя файла, то `class name` добавляется по умолчанию.

	$app->file("var/_test_13_ag/Tess.ag")->write("123");
	$app->syntaxAg->ag("var/_test_13_ag/Tess.ag");		# 123
	
	$app->file("var/_test_13_ag/Aes.ag")->write("class Aes \n 777 \n end");
	$app->syntaxAg->ag("var/_test_13_ag/Aes.ag");		# 777

Так же файл может начинаться на `extends` или `inherits`.
	
	$app->file("var/_test_13_ag/Ress.ag")->write("
	inherits ::Tour
		class Tour
		end
	911
	");
	$app->syntaxAg->ag("var/_test_13_ag/Ress.ag");		# 911
	
Любой класс без `inherits` по умолчанию наследует класс `Nil`.

	$app->file("var/_test_13_ag/Inherits.ag")->write("me isa 'Nil'");
	$app->syntaxAg->ag("var/_test_13_ag/Inherits.ag");		# 1

Код который не входит в объявление какого-то метода будет входить в неявный метод `render`. При попытке создать такой метод будет сгенерирована ошибка.
Команда `ag` подгружает `Aquafile` и указанный класс, создаёт экземпляр и запускает метод `render`.

`Aquafilе` содержит конфигурацию проекта. Поэтому он назван *Акваторией*.

Классы подгружаются оператором `new`, если класс ещё не был загружен. При этом по путям `app.syntaxAg:INC` ищется файл с расширением *.ag*.
Все файлы по вложенным путям в имени класса так же подгражаются - ведь в файле класса могут быть подклассы.

	$app->file("var/_test_13_ag/Nik.ag")->write("class Risk \n end");
	$app->file("var/_test_13_ag/Nik/Risk.ag")->write("1");
	
	$app->syntaxAg->ag("var/_test_13_ag/Nik/Risk.ag");	#@ ~ класс Nik::Risk встречается в .* и в .*
	
=== Тесты

	$app->file("var/_test_13_ag/Test.ag")->write("
		sub plus a,b then a+b
		scenario
			new Test.plus(10, 16)		# 26
		end
		6
	");
	$app->syntaxAg->ag("var/_test_13_ag/Test.ag");		# 6

	
=== Методы и свойства

Все переменные в *Серебрянке* - локальные, а свойства объектов доступны через `me` и его синонимы `self` и `this`:
	
	$app->syntaxAg->eval("
		class TestProperty
			sub new then self:a = 10
		end
	");
	
	$app->syntaxAg->eval("new TestProperty:a");			# 10

	
=== Декораторы


==== Контрактное программирование

Контрактное программирование использует декораторы.
Когда установлено `app.site.test` контракторы осуществляют проверки и выбрасывают эксепшены.
TODO:

== Конвееры
	
Конвеер обрабатывает список поэлементно и возвращает другой.
Конвееры могут быть левосторонними и правосторонними.
	
=== `map`

`map` считывает из потока элементов один элемент, а вот возвращать может ноль или более элементов в поток.
	
	$app->syntaxAg->eval("(1..3, 6 | a+1) join");			# 2347
	
Чтобы считать несколько элементов:
	
	$app->syntaxAg->eval("(1..3, 6 | x, y map x+y) join");			# 39
	$app->syntaxAg->eval("(1..3, 6 | map2 a+b) join");				# 39
	
=== `grep`

`grep` возвращает элементы, которые соответствуют условию.

	$app->syntaxAg->eval("(1..3, 6 | grep a < 3) join");					# 12
	$app->syntaxAg->eval("(1..3, 6 | grep2 b-a == 3) join");				# 36
	$app->syntaxAg->eval("(1..3, 6 | x, y grep y-x == 3) join");			# 36
	

=== `first`

Ищет первый элемент, удовлетворяющий условию.

	$app->syntaxAg->eval("(1..3, 6..10 | first a > 3) join");						# 6
	$app->syntaxAg->eval("(1..3, 6..10, 13 | first2 b-a >= 3) join");				# 36
	$app->syntaxAg->eval("(1..3, 6..10, 13 | x, y first y-x >= 3) join");			# 36

=== `any`

1, если какой-то из элементов списка удовлетворяет условию.

=== `all`

1, если все элементы списка удовлетворяют условию.

=== `sort`

Сортирует со строковым сравнением.

=== `order`

Сортирует с числовым сравнением.

=== `reduce`

Сворачивает список.

=== `group`

Группирует 


	
== Условия

=== `if`

	$app->syntaxAg->eval("if 0 then 10");						## undef
	$app->syntaxAg->eval("if 0 then 10 else 20");				# 20
	$app->syntaxAg->eval("if 0 then 10 elseif -1 then 20");		# 20
	$app->syntaxAg->eval("if 0 \n 10 \n end");					## undef
	$app->syntaxAg->eval("if 0 \n 10 \n else \n 20 \n end");	# 20
	$app->syntaxAg->eval("if 1 then s = 10 end; s");			# 10

== Циклы
	
=== `for`
	
	$app->syntaxAg->eval("s=''; for i in [1..2] then s .= i end; s");			# 12
	$app->syntaxAg->eval("s=''; for i = 1..2 then s .= i end; s");				# 12
	$app->syntaxAg->eval("s=''; for k, v of {1 => 10, 2 => 20} then s += i end; s");				# 3
	$app->syntaxAg->eval("s=''; for i, j, k = 1..10 then s .= '|' . i . j . k end; s");				# 123|456|789|10
	
=== `while`
	
	$app->syntaxAg->eval("while s < 12 then s++ end; s");			# 12
	$app->syntaxAg->eval("while s < 12 \n s++ \n end \n s");		# 12
	
=== `repeat`

	$app->syntaxAg->eval("repeat s++ until s==12; s");				# 12
	
=== Счётчики итераций в циклах

	$app->syntaxAg->eval("for i=1..2 then if index(i)==1 then last end end; i");			# 2
	$app->syntaxAg->eval("for i,j=1..6 then if index(i)==2 then last end end; i");			# 3
	
== Исключения

Оператор `rescue`, `catch`, `except` ловит исключение в коде перед собой и выполняет код после.

Оператор `die`, `throw`, `raise` посылает исключение.

Исключение должно наследовать 

	
== Операторы

=== Присваивания

Оператор `=` присваивает значение и возвращает его.

	$app->syntaxAg->new->eval("b=a=10; a+b");						# 20
	
Он имеет меньший приоритет, чем операторы `and`, `or`, `xor` и `not`:
	
	$app->syntaxAg->new->eval("a = 10 and 20; a");	# 10
	$app->syntaxAg->new->eval("a = 10 && 20; a");	# 20

Оператор `is` аналогичен `=`, но имеет больший приоритет:

	$app->syntaxAg->new->eval("a is 10 and 20; a");	# 20
	
Правосторонние операторы присваивания с низким и высоким приоритетом, соответственно:

	$app->syntaxAg->new->eval("20 and 10 as a; a");	# 10
	$app->syntaxAg->new->eval("20  && 10 -> a; a");	# 10

=== Логические

И:
	$app->syntaxAg->new->eval("20 and 10");	# 10
	$app->syntaxAg->new->eval("20  && 10");	# 10

Или:

	$app->syntaxAg->new->eval("20 or 10");	# 20
	$app->syntaxAg->new->eval("20 || 10");	# 20

Исключающее или:

	$app->syntaxAg->new->eval("20 xor 10");	## ""
	$app->syntaxAg->new->eval("20  ^^ 10");	## ""

Не:

	$app->syntaxAg->new->eval("not 0");		# 1
	$app->syntaxAg->new->eval("!0");		# 1

Надо заметить, что `not`, `xor`, `or` и `and` имеют более высокий приоритет:

	$app->syntaxAg->new->eval("(20, 30) and (10, 20, 30) join ','");		# 10,20,30
	
	# TODO: и работают с потоками данных - а вот и нет )))
	# (( 20, 30 ) && ( 10, 20, 30 )) => 10, 20, 30
	# (( 20, 30 )) || 1 => 30
	# (( 20, 30 )) or 1 => 30    vtf ???
	#$app->syntaxAg->new->eval("(20, 30)  && (10, 20, 30) join ','");		# 3
	
Проверка на `nothing`:

	$app->syntaxAg->new->eval("11?");			# 1
	$app->syntaxAg->new->eval("nothing?");		# 
	$app->syntaxAg->new->eval("nothing ? 2");	# 2
	
=== Сравнения

Сравнения строк (переводят скаляр в строку перед сравнением):

	$app->syntaxAg->new->eval("11 lt 100");		# 
	$app->syntaxAg->new->eval("11 gt 100");		# 1
	$app->syntaxAg->new->eval("11 le 100");		# 
	$app->syntaxAg->new->eval("11 ge 100");		# 1
	$app->syntaxAg->new->eval("11 ne 100");		# 1
	$app->syntaxAg->new->eval("11 eq 100");		# 
	
Сравнение чисел:
	
	$app->syntaxAg->new->eval("11 < 100");		# 1
	$app->syntaxAg->new->eval("11 > 100");		# 
	$app->syntaxAg->new->eval("11 <= 100");		# 1
	$app->syntaxAg->new->eval("11 >= 100");		# 
	$app->syntaxAg->new->eval("11 != 100");		# 1
	$app->syntaxAg->new->eval("11 == 100");		# 


	
=== Арифметические

	$app->syntaxAg->new->eval("+'34.5px'");		# 34.5
	$app->syntaxAg->new->eval("-'35.9px'");		# -35.9

	$app->syntaxAg->new->eval("1+1");		# 2
	$app->syntaxAg->new->eval("1-1");		# 0
	$app->syntaxAg->new->eval("4*5");		# 20
	$app->syntaxAg->new->eval("5/4");		# 1.25
	$app->syntaxAg->new->eval("3^3");		# 27
	
=== Инкремент и декремент
	
	$app->syntaxAg->new->eval("a=10; a++");			# 10
	$app->syntaxAg->new->eval("a=10; ++a");			# 11
	$app->syntaxAg->new->eval("a=10; a--");			# 10
	$app->syntaxAg->new->eval("a=10; --a");			# 9
	$app->syntaxAg->new->eval("a=10; a++; a");		# 11
	$app->syntaxAg->new->eval("a=10; a--; a");		# 9
	
=== Побитовые

	$app->syntaxAg->new->eval("0b0111 +& 0b0010");		## 0b0010
	$app->syntaxAg->new->eval("0b0001 +| 0b0010");		## 0b0011
	$app->syntaxAg->new->eval("0b1001 +^ 0b1010");		## 0b0011
	$app->syntaxAg->new->eval("+~ -1");					## 0
	$app->syntaxAg->new->eval("0b0001 +< 3");			## 0b1000
	$app->syntaxAg->new->eval("0b1001 +> 3");			## 0b0001
	
=== Строковые

Объединяет две строки.

	$app->syntaxAg->new->eval("10 . 20.2");				# 1020.2
	
Повторяет строку несколько раз.
	
	$app->syntaxAg->new->eval("5 ** 3");				# 555
	
Объединяет строки по разделителю.
	
	$app->syntaxAg->new->eval("10, 20 join ', '");		# 10, 20
	$app->syntaxAg->new->eval("10, 20 join");			# 1020
	
Разделяет строки по регулярному выражению или строке. Дополнительный параметр указывает количество раз которое нужно разделить.
	
	$app->syntaxAg->new->eval("['1,2,3' split '\d'!]");		## [1,2,3]
	$app->syntaxAg->new->eval("['1,2*3' split '(\d)'!]");	## [1, ',', 2, '*', 3]
	$app->syntaxAg->new->eval("['1*2*3' split '*']");		## [1,2,3]
	
	$app->syntaxAg->new->eval("['1,2,3' split '\d'!, 1]");		## [1,'2,3']
	$app->syntaxAg->new->eval("['1*2*3' split '*', 1]");		## [1,'2*3']
	
Если по чему разбивать не указано - разбивает по пробельным символам (`\s+`):
	
	$app->syntaxAg->new->eval("['1  2 3' split]");		## [1,2,3]
	
	$app->syntaxAg->new->eval("10, 20 | a+1	implode	', '");		# 11, 21
	$app->syntaxAg->new->eval("['1,2,3'	explode	',']");		## [1,2,3]
	
	$app->syntaxAg->new->eval("10, 20	implode	', '");		# 10, 20
	$app->syntaxAg->new->eval("'1,2,3'	explode	','");		## [1,2,3]
	

=== Регулярные

	$app->syntaxAg->new->eval('"7" ~ "^\d*$"!');		# 1
	$app->syntaxAg->new->eval('"7x" !~ "^\d*$"!');		# 1
	
	$app->syntaxAg->new->eval('"7" ~ "{\d}"~');		# 1
	$app->syntaxAg->new->eval('"7x" !~ "{\d}"~');	# 1
	
	
=== Интервальные

	$app->syntaxAg->new->eval(" ^6 join");			# 0123456

	$app->syntaxAg->new->eval(" 1..6 join");		# 123456
	$app->syntaxAg->new->eval(" 1...6 join");		# 12345
	
	$app->syntaxAg->new->eval(" 0 to 1 step .2 join ', ' ");		# 0, 0.2, 0.4, 0.6, 0.8, 1
	$app->syntaxAg->new->eval(" 1 to -2 step -1.5 join ', ' ");		# 1, -0.5, -2
	
`..*`, `...*` и `to *` - один и тот же оператор. Обозначает "до бесконечности". Значение `^*` - до бесконечности.
	
	$app->syntaxAg->new->eval(" (0..*)@[1..3] join");		# 123
	$app->syntaxAg->new->eval(" (0...*)@[1..3] join");		# 123
	$app->syntaxAg->new->eval(" (0 to *)@[1..3] join");		# 123
	
	$app->syntaxAg->new->eval(" (0..* step 2)@[1..3] join");		# 246
	
Операторы `^..` и  `^...` не включают начало интервала.
	
	$app->syntaxAg->new->eval(" 1^..6 join");					# 23456
	$app->syntaxAg->new->eval(" 1^...6 join");					# 2345
	$app->syntaxAg->new->eval("(1 ^to * step .2)@[0...5] join ', '");	# 0.2, 0.4, 0.6, 0.8, 1
	
Что так же полезно при сравнениях.

	$app->syntaxAg->new->eval(" 1 in 1^..6");					# 
	$app->syntaxAg->new->eval(" 1 in 1..6");					# 1
	$app->syntaxAg->new->eval(" 3 in 1..6");					# 3
	
`in` возвращает индекс первого найденного элемента от 1.
	
	
	
=== Для массивов
		
push:
	
	$app->syntaxAg->new->eval('a=[1]; @a ,= 2, 3; @a join');		# 123

shift:
	
	$app->syntaxAg->new->eval('a=[1,2,3]; b, c ,= @a; @a join');	# 3
	
unshift:

	$app->syntaxAg->new->eval('a=[1]; @a =, 2, 3; @a join');		# 231

pop:

	$app->syntaxAg->new->eval('a=[1,2,3]; b, c =, @a; @a join');	# 1
	
Запятая у `=` показывает в какую сторону будет производиться сдвиг.

slice:

	$app->syntaxAg->new->eval('a=[1,2,3,4,5,6]; a@[0,3,4] join');				# 145
	$app->syntaxAg->new->eval('a=[1,2,3,4,5,6]; a@[0,3,4] = 7,8,9; @a join');	# 7234896
	$app->syntaxAg->new->eval('a=[1,2,3,4,5,6]; a@[0,3,4] = 7; a');				## [7, 2, 3, 4, undef, undef, 6]

splice:

	$app->syntaxAg->new->eval('a=[1,2,3,4,5,6]; a@ 2, 4 = 7; @a join');		# 1276
	

=== Для хэшей

	$app->syntaxAg->new->eval('2 of {1=>10,2=>20,3=>30}');	# 1
	$app->syntaxAg->new->eval('2 of ^{1,2,3}');				# 1
	$app->syntaxAg->new->eval('{  ^{1,2,3}  }');			## {1=>undef, 2=>undef, 3=>undef}
	
	$app->syntaxAg->new->eval('2 of ^{1,2,3}');				# 1
	
=== Для объектов

Является или наследует ли объект указанный класс:

	$app->syntaxAg->new->eval('a = new Nil; a isa "Nil"');				# 1
	$app->syntaxAg->new->eval('a = new Nil; a isa "Nil1"');				# 
	
	$app->syntaxAg->new->eval('a = new Nil; a isa a');					# 1
	$app->syntaxAg->new->eval('a = new Nil; sense = new common::sense; a isa sense');		# 
	
Есть ли в классе метод:
	
	$app->syntaxAg->new->eval('a = new Nil; a can "new"');				# 1
	$app->syntaxAg->new->eval('a = new Nil; a can "xyz"');				# 
	
== ООП

=== Методы

	$app->syntaxAg->new->eval('class MethodTest
		sub slut b, c then me:number * b?1 + c
	end');
	
	$app->syntaxAg->new->eval('a = new MethodTest(number => 10); a.slut a.slut, a.slut + 6');	# 116
	$app->syntaxAg->new->eval('a = new MethodTest(number => 10); a.slut -+1');	# -10
	$app->syntaxAg->new->eval('a = new MethodTest(number => 10); a.slut -+1');	# -10
	
Тут `-` без пробела после него - по этому признаку происходит вызов метода с параметрами

=== Декораторы

Пример декоратора:

	$app->syntaxAg->new->eval('
	
	# добавляем сервис
	class R::Routers
		sub add name then @me:routers ,= name
	end
	
	class MyDecorator
		sub init then app.routers.add "$me:class.$me:name"
		sub replace me1 then
		sub before me1 then
		sub after me1 then
	end
	
	class DecoratorTest
		*MyDecorator
		sub myroute then
	end
	
	');
	
Экземпляр декоратора создаётся для каждого метода, который он декорирует.

Метод `init` декоратора вызывается при создании класса. В данном примере он собирает в сервис роутеров наименования методов.
	
`replace` будет выполняться вместо метода.
`before`  и `after` выполняются до и после метода, соответственно.

Свойство `me:name` содержит имя декорируемого метода.
Свойство `me:class` содержит имя класса.
Свойство `me:me` содержит контекст метода.

	