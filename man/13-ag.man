= Язык "Серебро" (Argentum)

== Инициализация фреймворка

[init]

	use common::sense;
	use lib "lib";
	use R::App qw/$app msg msg1/;
	
	$app->man->conf;
	
[test]


== Скаляры - строки и цифры

	$app->syntaxAg->new->eval("1");							# 1
	$app->syntaxAg->new->eval("1.1");						# 1.1
	$app->syntaxAg->new->eval("7_007_001_11_11");			# 70070011111
	$app->syntaxAg->new->eval("7_007_001_11_11.7_007");		# 70070011111.7007
	$app->syntaxAg->new->eval("-10");						# -10
	$app->syntaxAg->new->eval("0xFF");						# 255
	$app->syntaxAg->new->eval("0b10");						# 2
	$app->syntaxAg->new->eval("3r10");						# 3
	
	$app->syntaxAg->new->eval('"строка в utf8"');							# строка в utf8
	
Строки поддерживают интерполяцию:
	
	$app->syntaxAg->new->eval('utf8 = "utf8"; "строка в $utf8"');					# строка в utf8
	$app->syntaxAg->new->eval('hash = {key=>"utf8"}; "строка в $hash:key"');		# строка в utf8
	#$app->syntaxAg->new->eval('hash = {a=>6}; "строка в $a:6"');					# строка в utf8

== Классы и методы

=== Проект

Проект, это папка в которой лежит `Aquafile`.
Файлы с расширением `.ag` - классы на `Серебряне`.
Файлы с расширением `.au` - шаблоны.

Файлы в подпапках - это классы.
Компилляция просходит в подпапку `.Aqua` проекта.

*/myproject*
* _ .Aqua
* _ Aquafile

	my $dir = $app->file("var/_test_13_ag")->rm->mkdir;
	my $file = $dir->sub("/Tess.ag");
	
	$app->syntaxAg->ag($file->path);		#@ ~ файл находится не в проекте.* создайте Aquafile
	
Создадим *Aquafile*:
	
	my $Aquafile = $dir->sub("/Aquafile")->write("");
	
	$app->syntaxAg->ag($file->path);		#@ ~ нет “Tess.ag”

Компиляция исходников происходит в поддиректорию `.Aqua`. Причём первым компилируется *Aquafile*.

	$app->file("var/_test_13_ag/.Aqua/Aquafile.pm")->exists;		# 1

Если файл не начинается на `class name`, где `name` - имя файла, то `class name` добавляется по умолчанию.

	$app->file("var/_test_13_ag/Tess.ag")->write("123");
	$app->syntaxAg->ag("var/_test_13_ag/Tess.ag");		# 123
	
	$app->file("var/_test_13_ag/Aes.ag")->write("class Aes \n 777 \n end");
	$app->syntaxAg->ag("var/_test_13_ag/Aes.ag");		# 777

Так же файл может начинаться на `extends` или `inherits`.
	
	$app->file("var/_test_13_ag/Ress.ag")->write("
	inherits ::Tour
		class Tour
		end
	911
	");
	$app->syntaxAg->ag("var/_test_13_ag/Ress.ag");		# 911
	
Любой класс без `inherits` по умолчанию наследует класс `Nil`.

	$app->file("var/_test_13_ag/Inherits.ag")->write("me instanceof Nil");
	$app->syntaxAg->ag("var/_test_13_ag/Inherits.ag");		# 1

Код который не входит в объявление какого-то метода будет входить в неявный метод `render`. При попытке создать такой метод будет сгенерирована ошибка.
Команда `ag` подгружает `Aquafile` и указанный класс, создаёт экземпляр и запускает метод `render`.

`Aquafilе` содержит конфигурацию проекта. Поэтому он назван *Акваторией*.

Классы подгружаются оператором `new`, если класс ещё не был загружен. При этом по путям `app.syntaxAg:INC` ищется файл с расширением *.ag* или *.au* (именно в таком порядке).

	#$app->file("var/_test_13_ag/Ress.au")->write("{{ hi }}");
	
=== Тесты

	# $app->file("var/_test_13_ag/Test.ag")->write("
		# sub plus a,b then a+b
		# scenario
			# me.plus(10, 16)		# 26
		# end
		# 6
	# ");
	# $app->syntaxAg->ag("var/_test_13_ag/Test.ag");		# 6

	
=== Методы и свойства

Все переменные в *Серебрянке* - локальные, а свойства объектов доступны через `me` и его синонимы `self` и `this`:
	
	$app->syntaxAg->eval("
		class TestProperty
			sub new then self:a = 10
		end
	");
	
	$app->syntaxAg->eval("new TestProperty:a");			# 10

	
=== Декораторы


==== Контрактное программирование

Контрактное программирование использует декораторы.
Когда установлено `app.site.test` контракторы осуществляют проверки и выбрасывают эксепшены.
TODO:

== Конвееры
	
Конвеер обрабатывает список поэлементно и возвращает другой.
Конвееры могут быть левосторонними и правосторонними.
	
=== map

`map` считывает из потока элементов один элемент, а вот возвращать может ноль или более элементов в поток.
	
	$app->syntaxAg->eval("(1..3, 6 | a+1) join");			# 2347
	
	
== Условия

=== `if`

	$app->syntaxAg->eval("if 0 then 10");						## undef
	$app->syntaxAg->eval("if 0 then 10 else 20");				# 20
	$app->syntaxAg->eval("if 0 then 10 elseif -1 then 20");		# 20
	$app->syntaxAg->eval("if 0 \n 10 \n end");					## undef
	$app->syntaxAg->eval("if 0 \n 10 \n else \n 20 \n end");	# 20
	$app->syntaxAg->eval("if 1 then s = 10 end; s");			# 10

== Циклы
	
=== `for`
	
	$app->syntaxAg->eval("s=''; for i in [1..2] then s .= i end; s");			# 12
	$app->syntaxAg->eval("s=''; for i = 1..2 then s .= i end; s");				# 12
	$app->syntaxAg->eval("s=''; for k, v of {1 => 10, 2 => 20} then s += i end; s");				# 3
	$app->syntaxAg->eval("s=''; for i, j, k = 1..10 then s .= '|' . i . j . k end; s");				# 123|456|789|10
	
=== `while`
	
	$app->syntaxAg->eval("while s < 12 then s++ end; s");			# 12
	$app->syntaxAg->eval("while s < 12 \n s++ \n end \n s");		# 12
	
=== `repeat`

	$app->syntaxAg->eval("repeat s++ until s==12; s");			# 12
	
== Исключения


	
== Операторы

=== Присваивания

Оператор `=` присваивает значение и возвращает его.

	$app->syntaxAg->new->eval("b=a=10; a+b");						# 20
	
Он имеет меньший приоритет, чем операторы `and`, `or`, `xor` и `not`:
	
	$app->syntaxAg->new->eval("a = 10 and 20; a");	# 10
	$app->syntaxAg->new->eval("a = 10 && 20; a");	# 20

Оператор `is` аналогичен `=`, но имеет больший приоритет:

	$app->syntaxAg->new->eval("a is 10 and 20; a");	# 20
	
Правосторонние операторы присваивания с низким и высоким приоритетом, соответственно:

	$app->syntaxAg->new->eval("20 and 10 as a; a");	# 10
	$app->syntaxAg->new->eval("20  && 10 -> a; a");	# 10

=== Логические

И:
	$app->syntaxAg->new->eval("20 and 10");	# 10
	$app->syntaxAg->new->eval("20  && 10");	# 10

Или:

	$app->syntaxAg->new->eval("20 or 10");	# 20
	$app->syntaxAg->new->eval("20 || 10");	# 20

Исключающее или:

	$app->syntaxAg->new->eval("20 xor 10");	## ""
	$app->syntaxAg->new->eval("20  ^^ 10");	## ""

Не:

	$app->syntaxAg->new->eval("not 0");		# 1
	$app->syntaxAg->new->eval("!0");		# 1

Надо заметить, что `not`, `xor`, `or` и `and` имеют более высокий приоритет:

	$app->syntaxAg->new->eval("(20, 30) and (10, 20, 30) join ','");		# 10,20,30
	
	# TODO: и работают с потоками данных - а вот и нет )))
	# (( 20, 30 ) && ( 10, 20, 30 )) => 10, 20, 30
	# (( 20, 30 )) || 1 => 30
	# (( 20, 30 )) or 1 => 30    vtf ???
	#$app->syntaxAg->new->eval("(20, 30)  && (10, 20, 30) join ','");		# 3
	
=== Сравнения

Сравнения строк (переводят скаляр в строку перед сравнением):

	$app->syntaxAg->new->eval("11 lt 100");		# 
	$app->syntaxAg->new->eval("11 gt 100");		# 1
	$app->syntaxAg->new->eval("11 le 100");		# 
	$app->syntaxAg->new->eval("11 ge 100");		# 1
	$app->syntaxAg->new->eval("11 ne 100");		# 1
	$app->syntaxAg->new->eval("11 eq 100");		# 
	
Сравнение чисел:
	
	$app->syntaxAg->new->eval("11 < 100");		# 1
	$app->syntaxAg->new->eval("11 > 100");		# 
	$app->syntaxAg->new->eval("11 <= 100");		# 1
	$app->syntaxAg->new->eval("11 >= 100");		# 
	$app->syntaxAg->new->eval("11 != 100");		# 1
	$app->syntaxAg->new->eval("11 == 100");		# 
	
Проверка на `nothing`:

	$app->syntaxAg->new->eval("11?");			# 1
	$app->syntaxAg->new->eval("nothing?");		# 
	

	
=== Арифметические

	$app->syntaxAg->new->eval("+'34.5px'");		# 34.5
	$app->syntaxAg->new->eval("-'35.9px'");		# -35.9

	$app->syntaxAg->new->eval("1+1");		# 2
	$app->syntaxAg->new->eval("1-1");		# 0
	$app->syntaxAg->new->eval("4*5");		# 20
	$app->syntaxAg->new->eval("5/4");		# 1.25
	$app->syntaxAg->new->eval("3^3");		# 27
	
=== Инкремент и декремент
	
	$app->syntaxAg->new->eval("a=10; a++");			# 10
	$app->syntaxAg->new->eval("a=10; ++a");			# 11
	$app->syntaxAg->new->eval("a=10; a--");			# 10
	$app->syntaxAg->new->eval("a=10; --a");			# 9
	$app->syntaxAg->new->eval("a=10; a++; a");		# 11
	$app->syntaxAg->new->eval("a=10; a--; a");		# 9
	
=== Побитовые

	$app->syntaxAg->new->eval("0b0111 +& 0b0010");		## 0b0010
	$app->syntaxAg->new->eval("0b0001 +| 0b0010");		## 0b0011
	$app->syntaxAg->new->eval("0b1001 +^ 0b1010");		## 0b0011
	$app->syntaxAg->new->eval("+~ -1");					## 0
	$app->syntaxAg->new->eval("0b0001 +< 3");			## 0b1000
	$app->syntaxAg->new->eval("0b1001 +> 3");			## 0b0001
	
=== Для строк и массивов

	$app->syntaxAg->new->eval("10 . 20.2");				# 1020.2
	$app->syntaxAg->new->eval("10, 20 join ', '");		# 10, 20
	$app->syntaxAg->new->eval("['1,2,3' split '\d'!]");		## [1,2,3]
	
	$app->syntaxAg->new->eval("10, 20	.+	', '");		# 10, 20
	$app->syntaxAg->new->eval("'1,2,3'	./	','");		## [1,2,3]
	
	
	$app->syntaxAg->new->eval(" 1..6 join");		# 123456
	$app->syntaxAg->new->eval(" 1...6 join");		# 12345
	

== ООП



== 