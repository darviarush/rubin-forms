= Язык "Серебро" (Argentum)

== Инициализация фреймворка

[init]

	use common::sense;
	use lib "lib";
	use R::App qw/$app msg msg1/;
	
	$app->man->conf;
	
[test]


== Скаляры - строки и цифры

	$app->syntaxAg->new->eval("1");							# 1
	$app->syntaxAg->new->eval("1.1");						# 1.1
	$app->syntaxAg->new->eval("7_007_001_11_11");			# 70070011111
	$app->syntaxAg->new->eval("7_007_001_11_11.7_007");		# 70070011111.7007
	$app->syntaxAg->new->eval("-10");						# -10
	$app->syntaxAg->new->eval("0xFF");						# 255
	$app->syntaxAg->new->eval("0b10");						# 2
	$app->syntaxAg->new->eval("3r10");						# 3
	
	$app->syntaxAg->new->eval('"строка в utf8"');							# строка в utf8
	
Строки поддерживают интерполяцию:
	
	$app->syntaxAg->new->eval('utf8 = "utf8"; "строка в $utf8"');					# строка в utf8
	$app->syntaxAg->new->eval('hash = {key=>"utf8"}; "строка в $hash:key"');		# строка в utf8
	#$app->syntaxAg->new->eval('hash = {a=>6}; "строка в $a:6"');					# строка в utf8

== Классы и методы

=== Проект

Проект, это папка в которой лежит `Aquafile`.
Файлы с расширением `.ag` - классы на `Серебряне`.

Файлы в подпапках - это классы.
Компилляция просходит в подпапку `.Aqua` проекта.

*/myproject*
* _ .Aqua
* _ Aquafile

	my $dir = $app->file("var/_test_13_ag")->rm->mkdir;
	my $file = $dir->sub("/Tess.ag");
	
	$app->syntaxAg->ag($file->path);		#@ ~ файл находится не в проекте.* создайте Aquafile
	
Создадим *Aquafile*:
	
	my $Aquafile = $dir->sub("/Aquafile")->write("");
	
	$app->syntaxAg->ag($file->path);		#@ ~ нет “Tess.ag”

Компиляция исходников происходит в поддиректорию `.Aqua`. Причём первым компилируется *Aquafile*.

	$app->file("var/_test_13_ag/.Aqua/Aquafile.pm")->exists;		# 1

Если файл не начинается на `class name`, где `name` - имя файла, то `class name` добавляется по умолчанию.

	$app->file("var/_test_13_ag/Tess.ag")->write("123");
	$app->syntaxAg->ag("var/_test_13_ag/Tess.ag");		# 123
	
	$app->file("var/_test_13_ag/Aes.ag")->write("class Aes \n 777 \n end");
	$app->syntaxAg->ag("var/_test_13_ag/Aes.ag");		# 777

Так же файл может начинаться на `extends` или `inherits`.
	
	$app->file("var/_test_13_ag/Ress.ag")->write("
	inherits ::Tour
		class Tour
		end
	911
	");
	$app->syntaxAg->ag("var/_test_13_ag/Ress.ag");		# 911
	
Любой класс без `inherits` по умолчанию наследует класс `Nil`.

	$app->file("var/_test_13_ag/Inherits.ag")->write("me isa 'Nil'");
	$app->syntaxAg->ag("var/_test_13_ag/Inherits.ag");		# 1

Код который не входит в объявление какого-то метода будет входить в неявный метод `render`. При попытке создать такой метод будет сгенерирована ошибка.
Команда `ag` подгружает `Aquafile` и указанный класс, создаёт экземпляр и запускает метод `render`.

`Aquafilе` содержит конфигурацию проекта. Поэтому он назван *Акваторией*.

Классы подгружаются оператором `new`, если класс ещё не был загружен. При этом по путям `app.syntaxAg:INC` ищется файл с расширением *.ag*.
Все файлы по вложенным путям в имени класса так же подгражаются - ведь в файле класса могут быть подклассы.

	$app->file("var/_test_13_ag/Nik.ag")->write("class Risk \n end");
	$app->file("var/_test_13_ag/Nik/Risk.ag")->mkpath->write("1");
	
	#$app->syntaxAg->ag("var/_test_13_ag/Nik/Risk.ag");	#@ ~ класс Nik::Risk встречается в .* и в .*
	$app->syntaxAg->ag("var/_test_13_ag/Nik/Risk.ag");	#@ ~ Risk\.ag
	
=== Тесты

	$app->file("var/_test_13_ag/Test.ag")->write("
		sub plus a,b then a+b
		scenario
			a = new Test
		end
		
		6
		
		scenario
			if a.plus(10, 16) != 26 then 5 else 7
		end
	");
	$app->syntaxAg->ag("var/_test_13_ag/Test.ag");		# 6
	#$app->syntaxAg->ag("var/_test_13_ag/Test.ag", 1);	# 7

	
=== Методы и свойства

Все переменные в *Серебряне* - локальные, а свойства объектов доступны через `me` и его синонимы `self` и `this`:
	
	$app->syntaxAg->eval("
		class TestProperty
			sub new then self:a = 10
		end
	");
	
	$app->syntaxAg->eval("new TestProperty:a");			# 10


== Конвееры
	
Конвеер обрабатывает список поэлементно и возвращает другой.
Конвееры могут быть левосторонними и правосторонними.
	
=== `map`

`map` считывает из потока элементов один элемент, а вот возвращать может ноль или более элементов в поток.
	
	$app->syntaxAg->eval("(1..3, 6 | a+1) join");			# 2347
	
Чтобы считать несколько элементов:
	
	$app->syntaxAg->eval("(1..3, 6 | x, y map x+y) join");			# 39
	$app->syntaxAg->eval("(1..3, 6 | map2 a+b) join");				# 39
	$app->syntaxAg->eval("[ 1..3 | map2 b, a ]");				## [2, 1, undef, 3]
	
	$app->syntaxAg->eval("[ 1..6 | map3 c, b, a ]");				## [3, 2, 1, 6, 5, 4]
	$app->syntaxAg->eval("[ 1..7 | map3 c, b, a ]");				## [3, 2, 1, 6, 5, 4, undef, undef, 7]
	$app->syntaxAg->eval("[ 1..8 | map3 c, b, a ]");				## [3, 2, 1, 6, 5, 4, undef, 8, 7]
	
=== `grep`

`grep` возвращает элементы, которые соответствуют условию.

	$app->syntaxAg->eval("( 1..3, 6 | grep a < 3 ) join");					# 12
	$app->syntaxAg->eval("( 1..3, 6 | Grep2 b-a == 3 ) join");				# 36
	$app->syntaxAg->eval("( 1..3, 6 | x, y Grep y-x == 3 ) join");			# 36
	
	$app->syntaxAg->eval("[ 1..3    | x, y Grep x==3 || x==1 ]");			## [1, 2, 3]
	$app->syntaxAg->eval("[ 1..4    | grep3 1 ]");							## [1, 2, 3, 4]
	

=== `first`

Ищет первый элемент, удовлетворяющий условию.

	$app->syntaxAg->eval("(1..3, 6..10 | first a > 3) join");						# 6
	$app->syntaxAg->eval("(1..3, 6..10, 13 | first2 b-a >= 3) join");				# 36
	$app->syntaxAg->eval("(1..3, 6..10, 13 | x, y first y-x >= 3) join");			# 36

=== `any`

1, если какой-то из элементов списка удовлетворяет условию.

	$app->syntaxAg->eval("1..3 | any a==3");		# 1
	$app->syntaxAg->eval("1..3 | any a==4");		# 
	
	$app->syntaxAg->eval("1..3 | x, y Any x==3 and !y?");		# 1
	$app->syntaxAg->eval("1..3 | Any2 a==3 and !b?");		# 1

=== `all`

1, если все элементы списка удовлетворяют условию.

	$app->syntaxAg->eval("1..3 | all a > 0");		# 1
	$app->syntaxAg->eval("1..3 | All a < 3");		# 
	
	$app->syntaxAg->eval("1..3 | All3 a == 1");		# 1

=== `sort`

Сортирует со строковым сравнением.

	$app->syntaxAg->eval("[ 'abc', 'r', 'axc' | sort a ]");			## ['abc', 'axc', 'r']
	$app->syntaxAg->eval("[ 'abc', 'r', 'axc' | x sort x ]");		## ['abc', 'axc', 'r']
	
	$app->syntaxAg->eval("[ 'e', 'b', 'a', 'd', 'z' | x, y sort x ]");	## ['a', 'd', 'e', 'b', 'z', undef]

Обратите внимание на появившийся последний элемент.

=== `order`

Сортирует с числовым сравнением.

	msg1 $app->syntaxAg->morf("^3 | order -a | join");

	$app->syntaxAg->eval("^3 | order -a | join");			# 3210
	$app->syntaxAg->eval("^3 | x order -x | join");			# 3210
	
=== `assort`

Данная сортировка аналогична сортировке в языках *perl* и *javascript*, то есть позволяет сравнивать два элемента.

	#$app->syntaxAg->eval("^3 | assort b <=> a | join");					# 3210
	#$app->syntaxAg->eval("^3 | a, b assort b <=> a | join");			# 3210

=== `reduce`

Редукция. Сворачивает список к одному элементу.

	$app->syntaxAg->eval("1..3 | reduce a*b");				# 6
	$app->syntaxAg->eval("1..3 | x, y reduce x*y");			# 6
	$app->syntaxAg->eval("1..3 | reduce2 a*b");				# 6
	
В следующем примере редукция выполнит две итерации: 1*2-3 и -1*4-5.
	
	$app->syntaxAg->eval("1..5 | reduce3 a*b-c");			# -9
	$app->syntaxAg->eval("1..5 | x, y, z reduce x*y-z");	# -9

=== `group`

Группировка со строковым сравнением.

	$app->syntaxAg->eval("[ 1..66 |   group a div 10 ]");		## [[1..9], [10..19], [20..29], [30..39], [40..49], [50..59], [60..66]]
	$app->syntaxAg->eval("[ 1..66 | x group x div 10 ]");		## [[1..9], [10..19], [20..29], [30..39], [40..49], [50..59], [60..66]]
	
	$app->syntaxAg->eval("[ 1..66 | group2 a div 10 ]");		## [[1..10], [11..20], [21..30], [31..40], [41..50], [51..60], [61..66]]
	

=== `compress`

Группировка с числовым сравнением.

	$app->syntaxAg->eval("1..66 |   compress a div 10 | join ', '");			# 1, 10, 20, 30, 40, 50, 60
	$app->syntaxAg->eval("1..66 | x compress x div 10 | join ', '");			# 1, 10, 20, 30, 40, 50, 60

=== `join`

Добавлен для удобства работы с конвеерами: как бы оператор с другим приоритетом.

	$app->syntaxAg->eval("1..6 | join ', ' ");			# 1, 2, 3, 4, 5, 6
	$app->syntaxAg->eval("1..6 | join      ");			# 123456
	#$app->syntaxAg->eval("1..6 | join3       ");			# 123456

	
== Условия

=== `if`

	$app->syntaxAg->eval("if 0 then 10");						## undef
	$app->syntaxAg->eval("if 0 then 10 else 20");				# 20
	$app->syntaxAg->eval("if 0 then 10 elseif -1 then 20");		# 20
	$app->syntaxAg->eval("if 0 \n 10 \n end");					## undef
	$app->syntaxAg->eval("if 0 \n 10 \n else \n 20 \n end");	# 20
	$app->syntaxAg->eval("if 1 then s = 10 end; s");			# 10
	
=== `case`

	# my $res = $app->syntaxAg->eval("
		# a = 10
		# case a+1
			# when 1 then 30
			# when 2...6 then 50
			# when 8..10
				# 60
			# default 'default'
		# end
	# ");
	
	# $res; 		# default


== Циклы
	
=== `for`
	
	$app->syntaxAg->eval("s=''; for i in [1..2] then s .= i end; s");			# 12
	$app->syntaxAg->eval("s=''; for i = 1..2 then s .= i end; s");				# 12
	$app->syntaxAg->eval("s=''; for k, v of {1 => 10, 2 => 20} then s += i end; s");				# 3
	$app->syntaxAg->eval("s=''; for i, j, k = 1..10 then s .= '|' . i . j . k end; s");				# 123|456|789|10
	
=== `while`
	
	$app->syntaxAg->eval("while s < 12 then s++ end; s");			# 12
	$app->syntaxAg->eval("while s < 12 \n s++ \n end \n s");		# 12
	
=== `repeat`

	$app->syntaxAg->eval("repeat s++ until s==12; s");				# 12
	
=== Счётчики итераций в циклах

	$app->syntaxAg->eval("for i=1..2 then if index(i)==1 then last end end; i");			# 2
	$app->syntaxAg->eval("for i,j=1..6 then if index(i)==2 then last end end; i");			# 3
	
`index(var)` показывает индекс элемента в потоке данных. Поэтому во втором примере он будет принимать значения 0, 2, 4
	
== Исключения

Оператор `rescue`, `catch`, `except` ловит исключение в коде перед собой и выполняет код после.

Оператор `die`, `throw`, `raise` посылает исключение.

Исключение должно наследовать 

== `with`

`with` позволяет гарантированно закрыть объект, даже если в блоке произойдёт исключение. Оно добавляет к выражению 

	my $res = $app->syntaxAg->eval("
		with new R::File('var/test-1') as file
			file.print(10)
		end
	");			
	$res;		# 3

	
== Операторы

=== Присваивания

Оператор `=` присваивает значение и возвращает его.

	$app->syntaxAg->new->eval("b=a=10; a+b");						# 20
	
Он имеет меньший приоритет, чем операторы `and`, `or`, `xor` и `not`:
	
	$app->syntaxAg->new->eval("a = 10 and 20; a");	# 10
	$app->syntaxAg->new->eval("a = 10  && 20; a");	# 20

Оператор `is` аналогичен `=`, но имеет больший приоритет:

	$app->syntaxAg->new->eval("a is 10 and 20; a");	# 20
	
Правосторонние операторы присваивания с низким и высоким приоритетом, соответственно:

	$app->syntaxAg->new->eval("20 and 10 as a; a");	# 10
	$app->syntaxAg->new->eval("20  && 10 -> a; a");	# 10
	
	
	$app->syntaxAg->new->eval("a ?= 10");			# 10
	$app->syntaxAg->new->eval("a = 5; a ?= 10");	# 5
	$app->syntaxAg->new->eval("a=1;  a += 10");		# 11
	$app->syntaxAg->new->eval("a=10; a -= 10");		# 0
	$app->syntaxAg->new->eval("a=10; a *= 10");		# 100
	$app->syntaxAg->new->eval("a=10; a /= 100");	# 0.1
	$app->syntaxAg->new->eval("a=10; a div= 4");		# 2
	$app->syntaxAg->new->eval("a=10; a mod= 4");		# 1
	

=== Логические

И:
	$app->syntaxAg->new->eval("20 and 10");	# 10
	$app->syntaxAg->new->eval("20  && 10");	# 10

Или:

	$app->syntaxAg->new->eval("20 or 10");	# 20
	$app->syntaxAg->new->eval("20 || 10");	# 20

Исключающее или:

	$app->syntaxAg->new->eval("20 xor 10");	## ""
	$app->syntaxAg->new->eval("20  ^^ 10");	## ""

Не:

	$app->syntaxAg->new->eval("not 0");		# 1
	$app->syntaxAg->new->eval("!0");		# 1

Надо заметить, что `not`, `xor`, `or` и `and` имеют более высокий приоритет:

	$app->syntaxAg->new->eval("(20, 30) and (10, 20, 30) join ','");		# 10,20,30
	
	# TODO: и работают с потоками данных - а вот и нет )))
	# (( 20, 30 ) && ( 10, 20, 30 )) => 10, 20, 30
	# (( 20, 30 )) || 1 => 30
	# (( 20, 30 )) or 1 => 30    vtf ???
	#$app->syntaxAg->new->eval("(20, 30)  && (10, 20, 30) join ','");		# 3
	
Проверка на `nothing`:

	$app->syntaxAg->new->eval("11?");			# 1
	$app->syntaxAg->new->eval("nothing?");		# 
	$app->syntaxAg->new->eval("nothing ? 2");	# 2
	
=== Сравнения

Сравнения строк (переводят скаляр в строку перед сравнением):

	$app->syntaxAg->new->eval("11 lt 100");		# 
	$app->syntaxAg->new->eval("11 gt 100");		# 1
	$app->syntaxAg->new->eval("11 le 100");		# 
	$app->syntaxAg->new->eval("11 ge 100");		# 1
	$app->syntaxAg->new->eval("11 ne 100");		# 1
	$app->syntaxAg->new->eval("11 eq 100");		# 
	
Сравнение чисел:
	
	$app->syntaxAg->new->eval("11 < 100");		# 1
	$app->syntaxAg->new->eval("11 > 100");		# 
	$app->syntaxAg->new->eval("11 <= 100");		# 1
	$app->syntaxAg->new->eval("11 >= 100");		# 
	$app->syntaxAg->new->eval("11 != 100");		# 1
	$app->syntaxAg->new->eval("11 == 100");		# 


	
=== Арифметические

	$app->syntaxAg->new->eval("+'34.5px'");		# 34.5
	$app->syntaxAg->new->eval("-'35.9px'");		# -35.9

	$app->syntaxAg->new->eval("1+1");		# 2
	$app->syntaxAg->new->eval("1-1");		# 0
	$app->syntaxAg->new->eval("4*5");		# 20
	$app->syntaxAg->new->eval("5/4");		# 1.25
	$app->syntaxAg->new->eval("5 div 4");	# 1
	$app->syntaxAg->new->eval("5 mod 3");	# 2
	$app->syntaxAg->new->eval("3^3");		# 27
	
	# $app->syntaxAg->new->eval("3.25 ceil");		# 4
	# $app->syntaxAg->new->eval("3.25 floor");		# 3
	# $app->syntaxAg->new->eval("3.25 round");		# 3
	# $app->syntaxAg->new->eval("3.25 ceil 1");		# 3.3
	# $app->syntaxAg->new->eval("3.25 floor 1");		# 3.2
	# $app->syntaxAg->new->eval("3.25 round 1");		# 3.3
	
=== Инкремент и декремент
	
	$app->syntaxAg->new->eval("a=10; a++");			# 10
	$app->syntaxAg->new->eval("a=10; ++a");			# 11
	$app->syntaxAg->new->eval("a=10; a--");			# 10
	$app->syntaxAg->new->eval("a=10; --a");			# 9
	$app->syntaxAg->new->eval("a=10; a++; a");		# 11
	$app->syntaxAg->new->eval("a=10; a--; a");		# 9
	
=== Побитовые

	$app->syntaxAg->new->eval("0b0111 +& 0b0010");		## 0b0010
	$app->syntaxAg->new->eval("0b0001 +| 0b0010");		## 0b0011
	$app->syntaxAg->new->eval("0b1001 +^ 0b1010");		## 0b0011
	$app->syntaxAg->new->eval("+~ -1");					## 0
	$app->syntaxAg->new->eval("0b0001 +< 3");			## 0b1000
	$app->syntaxAg->new->eval("0b1001 +> 3");			## 0b0001
	
=== Строковые

Длина строки.

	$app->syntaxAg->new->eval("'abc' len");				# 3
	
Форматирование строки.

	$app->syntaxAg->new->eval("'x=%i y=%.2f' % (123, 2.555)");		# x=123 y=2.55

Объединяет две строки.

	$app->syntaxAg->new->eval("10 . 20.2");				# 1020.2
	
Повторяет строку несколько раз.
	
	$app->syntaxAg->new->eval("5 ** 3");				# 555
	
Объединяет строки по разделителю.
	
	$app->syntaxAg->new->eval("10, 20 join ', '");		# 10, 20
	$app->syntaxAg->new->eval("10, 20 join");			# 1020
	
Разделяет строки по регулярному выражению или строке. Дополнительный параметр указывает количество раз которое нужно разделить.
	
	$app->syntaxAg->new->eval("['1,2,3' split '\d'!]");		## [1,2,3]
	$app->syntaxAg->new->eval("['1,2*3' split '(\d)'!]");	## [1, ',', 2, '*', 3]
	$app->syntaxAg->new->eval("['1*2*3' split '*']");		## [1,2,3]
	
	$app->syntaxAg->new->eval("['1,2,3' split '\d'!, 1]");		## [1,'2,3']
	$app->syntaxAg->new->eval("['1*2*3' split '*', 1]");		## [1,'2*3']
	
Если по чему разбивать не указано - разбивает по пробельным символам (`\s+`):
	
	$app->syntaxAg->new->eval("['1  2 3' split]");		## [1,2,3]
	

=== Регулярные

	$app->syntaxAg->new->eval('"7" ~ "^\d*$"!');		# 1
	$app->syntaxAg->new->eval('"7x" !~ "^\d*$"!');		# 1
	
	$app->syntaxAg->new->eval('"7" ~ "{\d}"~');		# 1
	$app->syntaxAg->new->eval('"7x" !~ "{\d}"~');	# 1
	
	
=== Интервальные

	$app->syntaxAg->new->eval(" ^6 join");			# 0123456

	$app->syntaxAg->new->eval(" 1..6 join");		# 123456
	$app->syntaxAg->new->eval(" 1...6 join");		# 12345
	
	$app->syntaxAg->new->eval(" 0 to 1 step .2 join ', ' ");		# 0, 0.2, 0.4, 0.6, 0.8, 1
	$app->syntaxAg->new->eval(" 1 to -2 step -1.5 join ', ' ");		# 1, -0.5, -2
	
`..*`, `...*` и `to *` - один и тот же оператор. Обозначает "до бесконечности". Значение `^*` - до бесконечности.
	
	$app->syntaxAg->new->eval(" (0..*)@[1..3] join");		# 123
	$app->syntaxAg->new->eval(" (0...*)@[1..3] join");		# 123
	$app->syntaxAg->new->eval(" (0 to *)@[1..3] join");		# 123
	
	$app->syntaxAg->new->eval(" (0..* step 2)@[1..3] join");		# 246
	
Так же работает и с `inf`:
	
	$app->syntaxAg->new->eval(" (0...Inf)@[1..3] join");		# 123
	
	
Операторы `^..`, `^to` и  `^...` не включают начало интервала.
	
	$app->syntaxAg->new->eval(" 1^..6 join");					# 23456
	$app->syntaxAg->new->eval(" 1^...6 join");					# 2345
	$app->syntaxAg->new->eval("(1 ^to * step .2)@[0...5] join ', '");	# 0.2, 0.4, 0.6, 0.8, 1
	
Что так же полезно при сравнениях.

	$app->syntaxAg->new->eval(" 1 in 1^..6");					# 
	$app->syntaxAg->new->eval(" 1 in 1..6");					# 1
	$app->syntaxAg->new->eval(" 3 in 1..6");					# 3
	
`in` возвращает индекс первого найденного элемента от 1.
	
	
	
=== Для массивов
	
`reverse` - переворачивает список. 

	$app->syntaxAg->eval(" ^3, 6 reverse join");					# 63210
	
`zip` - объединяет списки.

	$app->syntaxAg->eval("[1..3 zip 4,5 zip 9..11]");		## [1,4,9,2,5,10,3,undef,11]

	
`push` - добавляет элементы в конец списка.
	
	$app->syntaxAg->new->eval('a=[1]; @a ,= 2, 3; @a join');		# 123

shift:
	
	$app->syntaxAg->new->eval('a=[1,2,3]; b, c ,= @a; @a join');	# 3
	
unshift:

	$app->syntaxAg->new->eval('a=[1]; @a =, 2, 3; @a join');		# 231

pop:

	$app->syntaxAg->new->eval('a=[1,2,3]; b, c =, @a; @a join');	# 1
	
Запятая у `=` показывает в какую сторону будет производиться сдвиг.

slice:

	$app->syntaxAg->new->eval('a=[1,2,3,4,5,6]; a@[0,3,4] join');				# 145
	$app->syntaxAg->new->eval('a=[1,2,3,4,5,6]; a@[0,3,4] = 7,8,9; @a join');	# 7234896
	$app->syntaxAg->new->eval('a=[1,2,3,4,5,6]; a@[0,3,4] = 7; a');				## [7, 2, 3, 4, undef, undef, 6]

splice:

	$app->syntaxAg->new->eval('a=[1,2,3,4,5,6]; a@ 2, 4 = 7; @a join');		# 1276
	

=== Для хэшей

	$app->syntaxAg->new->eval('2 of {1=>10,2=>20,3=>30}');	# 1
	$app->syntaxAg->new->eval('2 of ^{1,2,3}');				# 1
	$app->syntaxAg->new->eval('{  ^{1,2,3}  }');			## {1=>undef, 2=>undef, 3=>undef}
	
	$app->syntaxAg->new->eval('2 of ^{1,2,3}');				# 1
	
=== Для объектов

Является или наследует ли объект указанный класс:

	$app->syntaxAg->new->eval('a = new Nil; a isa "Nil"');				# 1
	$app->syntaxAg->new->eval('a = new Nil; a isa "Nil1"');				# 
	
	$app->syntaxAg->new->eval('a = new Nil; a isa a');					# 1
	$app->syntaxAg->new->eval('a = new Nil; sense = new common::sense; a isa sense');		# 
	
Есть ли в классе метод:
	
	$app->syntaxAg->new->eval('a = new Nil; a can "new"');				# 1
	$app->syntaxAg->new->eval('a = new Nil; a can "xyz"');				# 
	
== ООП

=== Методы

	$app->syntaxAg->new->eval('class MethodTest
		sub slut b, c then me:number * b?1 + c
	end');
	
	$app->syntaxAg->new->eval('a = new MethodTest(number => 10); a.slut a.slut, a.slut + 6');	# 116
	$app->syntaxAg->new->eval('a = new MethodTest(number => 10); a.slut -+1');	# -10
	$app->syntaxAg->new->eval('a = new MethodTest(number => 10); a.slut -+1');	# -10
	
Тут `-` без пробела после него - по этому признаку происходит вызов метода с параметрами.

=== Декораторы

Пример декоратора:

	$app->syntaxAg->new->eval('
	
	# добавляем сервис
	class R::Routers
		sub add name then @me:routers ,= name
	end
	
	class MyDecorator
		sub init then app.routers.add "$me:args[0] $me:class.$me:name"
		sub replace me1 then
		sub before me1 then
		sub after me1 then
	end
	
	class DecoratorTest
		*MyDecorator "/page"
		sub myroute then
	end
	
	');
	
Экземпляр декоратора создаётся для каждого метода, который он декорирует.

Метод `init` декоратора вызывается при создании класса. В данном примере он собирает в сервис роутеров наименования методов.
	
`replace` будет выполняться вместо метода.
`before`  и `after` выполняются до и после метода, соответственно.

Свойство `me:name` содержит имя декорируемого метода.
Свойство `me:class` содержит имя класса.
Свойство `me:me` содержит контекст метода.
Свойство `me:args` содержит аргументы декторатора.



==== Контрактное программирование

Контрактное программирование использует декораторы.
Когда установлено `app.site.test` контракторы осуществляют проверки и выбрасывают эксепшены.
TODO:

	# $app->syntaxAg->new->eval('
		# class ContractTest
			# * param "int", "r", "..."
			# * param "float", "x", "..."
			# sub new r, x then 
		# end
	# ');
