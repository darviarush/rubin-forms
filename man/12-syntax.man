= Язык шаблонизатора R::View

== Инициализация фреймворка

[init]

	use common::sense;
	use lib "lib";
	use R::App qw/$app msg msg1/;
	
	$app->man->conf;
	
	my $res;
	
[test]


== Синтаксический анализатор

Синтаксический анализатор 

	my $s = $app->syntax->new;
	
Вот так задаётся таблица операторов:
	
	$s->tr("fy", qw{ + - });
	$s->tr("yfx", qw{ ^ });
	$s->tr("xfy", qw{ * / });
	$s->tr("xfy", qw{ + - });
	
* `tr` - строка таблицы, она увеличивает приоритет оператора.
* `td`- ячейка. Не увеличивает приоритет.

Скобки:

	$s->br(qw{ ( ) });

Терминалы:
	
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);

Первым параметром выступает префикс.
	
Каждый оператор, скобка или операнд имеет отображение в иной язык программирования (в нашем случае в `perl`, но может быть и в `javascript`).
Добавим отображения:
	
	
	$s->templates(
		"fy +" => "0+({{ right }})",
		"fy	-" => "-({{ right }})",
		"yfx ^" => "({{ left }}) ** ({{ right }})",
		"xfy *" => "({{ left }}) * ({{ right }})",
		"xfy /" => "({{ left }}) / ({{ right }})",
		"xfy +" => "({{ left }}) + ({{ right }})",
		"xfy -" => "({{ left }}) - ({{ right }})",
		"(" => "( {{ right }} )",
		"num" => "{{ num }}",
	);
	
	
	
	$s->eval("-1");				# -1
	$s->eval("1 + -5");			# -4
	$s->eval("6+3*2");			# 12
	$s->eval("(6+3)*2");		# 18
	$s->eval("-(6+3)*2");		# -18
	$s->eval("-(6+3)*-2");		# 18
	

=== Оператор как операнд
	
Синтаксический анализатор может распознавать случаи когда операторы выступают операндами.
Так часто `*` может выступать как умножение `a * b` и как бесконечность: `0 ... *`

	my $s = $app->syntax->new;
	
	$s->tr("xfy", qw/ * /);
	$s->tr("xfx", qw/ ... /);
	$s->x("*");
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	
	$s->templates(
		"xfy *" => "{{ left }} * {{ right }}",
		"xfx ..." => "{{ left }} .. {{ right }}",
		"*" => 1000,
		"num" => "{{ num }}",
	);
	
Умножаем 5 на 1000:
	
	$s->eval("5**");				# 5000
	
А тут получаем список от 500 до 1000:
	
	scalar @{[ $s->eval("5*100 ... *") ]};		# 501
	
	
=== Постфиксный и инфиксный операторы

Если оператор является и инфиксным и постфиксным одновременно, и в конце выражения стоит несколько таких операторов, то распознаются они как постфиксные. 
	
	my $s = $app->syntax->new;
	
	$s->tr("yf", qw/ + /);
	$s->tr("xfy", qw/ + /);
	
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	
	$s->templates(
		"xfy +" => "{{ left }} + {{ right }}",
		"yf +" => "{{ left }} + 1",
		"num" => "{{ num }}",
	);
	
	$s->eval("5++");		# 7

	
=== Приоритет постфиксных операторов

Постфиксный оператор с более высоким приоритетом выталкивает операторы с меньшим:

	my $s = $app->syntax->new;
	
	$s->tr("xfy", qw/ + /);
	$s->tr("yf", qw/ + /);
	$s->tr("yf", qw/ * /);
	
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	
	$s->templates(
		"xfy +" => "({{ left }}) + ({{ right }})",
		"yf +" => "({{ left }})+1",
		"yf *" => "({{ left }})*-1",
		"num" => "{{ num }}",
	);

	$s->eval("5+6*");		# -11
	
А вот с постфиксными операторами:
	
	$s->eval("5+6+*");		# -10
	$s->eval("5+6*+");		# -10
	
Построилось дерево `(((5+6)*-1)+1)`. Тут выбрасываются постфиксные операторы в порядке поступления.

	
== Всраивание языков программирование один в другой

Это может понадобиться как для интерпояции строк, так и для создания шаблонов и в регулярных выражениях.

Создаём синтаксический анализатор для строк и для выражений.

	my $string = $app->syntax->new;
	my $s = $app->syntax->new;
	
	# отключаем добавление лексем
	$string->addspacelex(0);
	
	$string->tr("yfx", qw/CAT/)->tr("yf", qw/CAT/);
	
	$string->opt("CAT", nolex => 1);
	$string->x(exec => qr/ (?<str> .*? ) \$ (?<exec> \S+ ) /xs => sub {
		my ($self, $push) = @_;
		$self->checkout->push("exec1")->masking($push->{exec})->pop("exec1")->checkout($self->{LA_STRING})->op("CAT");
	});
	$string->x("str" => qr/ (?<str> .* ) \z /xs => sub { shift->op("CAT") });
	
	$s->{LA_STRING} = $string;
	
	$s->tr("xfy", qw/ + /);
	$s->tr("yf", qw/ * /);
	
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	$s->x("string" => qr{ "(?: \\"|[^\\"] )*" }x => sub {
		my ($self, $push) = @_;
		$self->checkout($self->{LA_STRING})->push("string1")->masking($push->{string})->pop("string1")->checkout->op("CAT");
	});
	
	$s->templates(
		"xfy +" => "({{ left }}) + ({{ right }})",
		"yf +" => "({{ left }})+1",
		"yf *" => "({{ left }})*-1",
		"num" => "{{ num }}",
		"CAT" => "{{ left }}{{ right }}",
		"str" => "{{ str }}",
		"string1" => '"{{ right }}"',
		"exec1" => '{{ str }}${\({{ right }})}"',
	);

	$s->eval('"_ $5+6* _"');		# _ -11 _

