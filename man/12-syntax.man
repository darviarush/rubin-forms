= Язык шаблонизатора R::View

== Инициализация фреймворка

[init]

	use common::sense;
	use lib "lib";
	use R::App qw/$app msg msg1/;
	
	$app->man->conf;
	
	my $res;
	
[test]


== Синтаксический анализатор

Синтаксический анализатор 

	my $s = $app->syntax->new(trace=>0, show=>0);
	
Вот так задаётся таблица операторов:
	
	$s->tr("yF", qw{ [ ] });
	$s->tr("fy", qw{ + - });
	$s->tr("yfx", qw{ ^ });
	$s->tr("xfy", qw{ * / });
	$s->tr("xfy", qw{ + - });
	$s->tr("xfy", qw{ = });
	$s->tr("xfy", qw{ ; });
	
* `tr` - строка таблицы, она увеличивает приоритет оператора.
* `td`- ячейка. Не увеличивает приоритет.

Арность и ассоциативность задаются так:

* `f` - функтор (другое название оператора)
* `x` - неассоциативный оператор: `xfx`, `xf`, `fx` и `xF`
* `y` - сторона с которой происходит свёртка. Ассоциативные операторы: `xfy`, `yfx`, `yf`, `fy` и `yF`

Скобки:

	$s->br(qw{ ( ) });
	$s->br(qw{ [ ] });

Терминалы:
	
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	$s->x("var" => qr{ [a-z]\w* }ix);

Первым параметром выступает префикс.
	
Каждый оператор, скобка или операнд имеет отображение в иной язык программирования (в нашем случае в `perl`, но может быть и в `javascript`).
Добавим отображения:
	
	
	$s->templates(
		"yF [" => "({{ left }})->[ {{ right }} ]",
		"fy +" => "0+({{ right }})",
		"fy	-" => "-({{ right }})",
		"yfx ^" => "({{ left }}) ** ({{ right }})",
		"xfy *" => "({{ left }}) * ({{ right }})",
		"xfy /" => "({{ left }}) / ({{ right }})",
		"xfy +" => "({{ left }}) + ({{ right }})",
		"xfy -" => "({{ left }}) - ({{ right }})",
		"xfy =" => "({{ left }}) = ({{ right }})",
		"xfy ;" => "{{ left }}; {{ right }}",
		"(" => "( {{ right }} )",
		"[" => "[ {{ right }} ]",
		"num" => "{{ num }}",
		"var" => '${{ var }}',
	);
	
	$s->eval("-1");				# -1
	$s->eval("1 + -5");			# -4
	$s->eval("6+3*2");			# 12
	$s->eval("(6+3)*2");		# 18
	$s->eval("-(6+3)*2");		# -18
	$s->eval("-(6+3)*-2");		# 18
	
	$s->{trace} = 1;
	$s->{show} = 1;
	msg1 $s->morf("a[0] = -(6+3)*-2; a[0]-10");
	$s->eval("a=[]; a[0] = -(6+3)*-2; a[0]-10");		# 8
	

=== Оператор как операнд
	
Синтаксический анализатор может распознавать случаи когда операторы выступают операндами.
Так часто `*` может выступать как умножение `a * b` и как бесконечность: `0 ... *`

	my $s = $app->syntax->new;
	
	$s->tr("xfy", qw/ * /);
	$s->tr("xfx", qw/ ... /);
	$s->x("*");
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	
	$s->templates(
		"xfy *" => "{{ left }} * {{ right }}",
		"xfx ..." => "{{ left }} .. {{ right }}",
		"*" => 1000,
		"num" => "{{ num }}",
	);
	
Умножаем 5 на 1000:
	
	$s->eval("5**");				# 5000
	
А тут получаем список от 500 до 1000:
	
	scalar @{[ $s->eval("5*100 ... *") ]};		# 501
	
	
=== Постфиксный и инфиксный операторы

Если оператор является и инфиксным и постфиксным одновременно, и в конце выражения стоит несколько таких операторов, то распознаются они как постфиксные. 
	
	my $s = $app->syntax->new(show=>1);
	
	$s->tr("yf", qw/ + /);
	$s->tr("xfy", qw/ + /);
	
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	
	$s->templates(
		"xfy +" => "{{ left }} + {{ right }}",
		"yf +" => "{{ left }} + 1",
		"num" => "{{ num }}",
	);
	
	$s->eval("5++");		# 7

	
=== Приоритет постфиксных операторов

Постфиксный оператор с более высоким приоритетом выталкивает операторы с меньшим:

	my $s = $app->syntax->new;
	
	$s->tr("xfy", qw/ + /);
	$s->tr("yf", qw/ + /);
	$s->tr("yf", qw/ * /);
	
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	
	$s->templates(
		"xfy +" => "({{ left }}) + ({{ right }})",
		"yf +" => "({{ left }})+1",
		"yf *" => "({{ left }})*-1",
		"num" => "{{ num }}",
	);

	$s->eval("5+6*");		# -11
	
А вот с постфиксными операторами:
	
	$s->eval("5+6+*");		# -10
	$s->eval("5+6*+");		# -10
	
Построилось дерево `(((5+6)*-1)+1)`. Тут выбрасываются постфиксные операторы в порядке поступления.

	
== Всраивание языков программирование один в другой

Это может понадобиться как для интерпояции строк, так и для создания шаблонов и в регулярных выражениях.

Создаём синтаксический анализатор для строк и для выражений.

	my $string = $app->syntax->new(name => "string");
	my $s = $app->syntax->new(name => "master");
	# подключаем строковый анализатор к языковому анализатору
	$s->bar( $string );
	
	# отключаем добавление дефолтных лексем
	$string->addspacelex(0);
	
	$string->tr("yfx", qw/CAT/)->td("yf", qw/CAT/);
	$string->x(qw/CAT/);
	
	$string->br(qw/exec1/);
	$string->opt("exec1", nolex => 1);
	
	
	$string->opt("CAT", re => qr/ (?<str> [^\$]* ) ( \$ (?<CAT> \S+ ) | $ ) /xs, sub => sub {
		my ($self, $push) = @_;
		if(exists $push->{CAT}) {
			$self->checkout("master")->push("exec1")->masking($push->{CAT})->pop("exec1")->checkout("string");
			delete $push->{str};
		}
	});
	
	$s->tr("xfy", qw/ + /);
	$s->tr("yf", qw/ * /);
	
	$s->x("num" => qr{ \d+|\d*\.\d+ }x);
	$s->x("string" => qr{ "(?<string_in> (?: \\"|[^\\"] )* )" }x => sub {
		my ($self, $push) = @_;
		$self->checkout("string")->push("string")->masking($push->{string_in})->pop("string")->checkout("master")->assign($push);
	});
	
	$s->templates(
		"xfy +" => "({{ left }}) + ({{ right }})",
		"yf +" => "({{ left }})+1",
		"yf *" => "({{ left }})*-1",
		"num" => "{{ num }}",
		"yfx CAT" => "{{ left }}{{ str }}{{ right }}",
		"yf CAT" => "{{ left }}{{ str }}",
		"CAT" => '{{ str }}',
		"string" => '"{{ right }}"',
		"exec1" => '{{ str }}${\({{ right }})}',
	);
	
	$s->eval('"_"');				# _
	$s->eval('"_ $5"');				# _ 5
	$s->eval('"$6 _"');				# 6 _
	$s->eval('"_ $5+6* _"');		# _ -11 _
	$s->eval('"_ $6 _ $6+1 _"');	# _ 6 _ 7 _
	

== Модификаторы бинарного синтаксического дерева

После того как код распознан и с него было сформировано бинарное дерево оно обходится и по маскам запускаются функции-модификаторы.

Модификаторы есть как в синтаксе, так и в морфе.
	
	my $s = $app->syntax->new;
	
	# $s->tr("xfy", qw/ = /);
	# $s->tr("xf", qw/ @ /);
	# $s->tr("xfy", qw/ , /);
	
	# $s->x("num" => qr{ \d+|\d*\.\d+ }x);
	
	# $s->modifiers(
		# 'xf @' => sub { my ($self, $x) = @_; $x->{tmpl} = '@=' },
	# );
	
	# $s->templates(
		# 'xf @' => "@{ {{ left }} }",
		# "yf +" => "({{ left }})+1",
		# "yf *" => "({{ left }})*-1",
		# "num" => "{{ num }}",
	# );

	# $s->eval(' @y = 3, 4;  @m = @x = 1, 2, @y ');		# -11

