#!/usr/bin/env perl
# Система тестирования, документирования и публикаций в интернете

#package RrruMiu;

chdir "$`/.." if $0 =~ /\/[^\/]*$/;

#use lib "lib";
#use R::App;
use common::sense;
use Getopt::Long qw/:config no_ignore_case bundling/;
use POSIX qw/dup2/;

my %opt;

GetOptions(
	"p|public" => \$opt{public},
	"t|test" => \$opt{test},
	"l|log" => \$opt{log},
	"s|stat" => \$opt{stat},
	"h|help" => \$opt{help},
);


# маска файлов, маска заголовков
($opt{pattern}, $opt{art_pattern}) = @ARGV;


mkdir "miu-rrrumiu";


my $miu = bless \%opt, "Miu";
$miu->run;

# if( $miu->test && $miu->{public}) {
	# $miu->post;
# }


# класс
package Miu;

use File::Find qw//;

# парсит и запускает тесты
sub run {
	my ($self) = @_;	
	
	if($self->{help}) {
		print "miu [опции] [маска_файлов] [маска_разделов]

miu компилирует файлы в код, тесты и статьи. Выполняет тесты и публикует статьи в интернете.
		
ОПЦИИ
    -p, --public        опубликовать в интернте, см. etc/miu.sample.ini
    -t, --test          не компилировать: выполнить тесты
    -l, --log           лог в stdout
    -s, --stat          статистику в stdout
    -h, --help          эта справка
";
		exit;
	}
	
	$self->{log} = 1 if $self->{stat};
	
	my $count = 0;
	
	# парсим файл и переписываем
	$self->find(sub {
		my ($path) = @_;
		
		$count++;
		
		$_ = $path;
		s/^miu\///;
		print "$_ ";
		
		$self->{path} = $path;
		$_ = $self->{path};
		s!miu!miu-rrrumiu!;
		s/\.\w+$/.markdown/;
		$self->{article_path} = $_;
		s/\.\w+$/.t/;
		$self->{test_path} = $_;
		
		$self->compile if !$self->{test};
				
		exit unless $self->test;
		
	});
	
	print "Не найдено ни одного теста\n" if $self->{count_tests} == 0;
	
}


# разбивает файл на 3 части: код, тест и документацию
sub compile {
	my ($self) = @_;
	
	my $path = $self->{path};
	open my $file, "<:encoding(utf8)", $path or die "Не могу открыть файл miu $path: $!";
	
	# статья-файл
	open my $articleFile, ">:encoding(utf8)", $self->{article_path} or die "Не могу открыть файл статьи $self->{article_path}: $!";
	
	# файл кода
	my $codeFile;
	
	# тест-файл
	$_ = $path;

	open my $testFile, ">:encoding(utf8)", $self->{test_path} or die "Не могу открыть файл теста $self->{test_path}: $!";
	
	# подготавливаем разбитие по разделам статьи
	my $art_pattern = $self->{art_pattern} // "";
	utf8::decode($art_pattern);
	my $art_len = length($art_pattern);
	my $test_write = $art_pattern? 0: 1;
	
	# разбиваем
	my ($test, $code) = (1,0);
	my @test;
	my @TEST;
	my $count_tests = 0;
	my $lines = $self->{lines} = [1];
	
	while(<$file>) {
		($code, $test) = (1,0), continue if /^[code]\s*$/;
		($code, $test) = (0,1), continue if /^[test]\s*$/;
		
		print $articleFile $_;

		if($art_pattern && /^(={2,})\s*/) {
			
			my $last = $';
			my $level = length $1;
			
			if(uc($art_pattern) eq uc substr $last, 0, $art_len) {
				$test_write = $level;
			}
			elsif($level <= $test_write) {
				$test_write = 0;
			}
		}
		
		######### [тест или код]
		if(s/^(\t| {4})//) {
		
			###################### [code]
			if($code) {
				
				if(/^\s*package ([\w:])+/) {
					my $package = $1;
					close $codeFile if $codeFile;
					$codeFile = packfile($package, $path);
				}
				
				if(!$codeFile && !/^\s*$/) {
					$_ = $path;
					s!miu!miu-rrrumiu!;
					s/\.miu$/.code.pl/;
					open $codeFile, "<", $_ or die "Не могу открыть файл для записи кода $_: $!";
				}
				
				print $codeFile $_;
			}
			
			###################### [test]
			elsif($test && $test_write) {
				
				my $replace = sub {
					$count_tests ++;
					
					push @$lines, $.;
					
					my ($start, $code, $who, $op, $op2, $end) = ($1, $2, $3, $4, $5, $6);
					
					$op //= $op2;
					
					$end =~ s/^\s*(.*?)\s*$/$1/;
					if(!$code) {
					
						if($op eq "~" or $op eq "!~") {
							$end = "qr{$end}";
						} else {
							$end =~ s/["\@\$]/\\$&/g;
							$end =~ s/\\s/ /g;
							$end = "\"$end\"";
						}
					}
					
					my $_test = "";
					my $_cmp = "";
					
					# if(defined $fileno) { # 6>
						# unshift @test, "___std($fileno);\n";
						# push @test, $start, "; ___res($fileno);\n";
						# $start = "___get()";
					# }
					if($who eq ">>") {	#STDOUT
						unshift @test, "___std(\\*STDOUT);\n";
						push @test, $start, "; ___res(\\*STDOUT);\n";
						$start = "___get()";
					}
					elsif($who eq "&>") {	#STDERR
						unshift @test, "___std(\\*STDERR);\n";
						push @test, $start, "; ___res(\\*STDERR);\n";
						$start = "___get()";
					}
					elsif($who eq "\@") {
						unshift @test, "eval { ";
						push @test, "$start }; ";
						$start = "\$@";
					}
					elsif($who eq "!") {
						push @test, "$start; ";
						$start = "\$!";
					}
					
					$start =~ s/;$//;
					$end =~ s/;$//;
					
					$start = "scalar($start)";
					$end = "scalar($end)";
					
					if(!$op) {
						"is_deeply( $start, $end );";
					} elsif($op eq "startswith") {
						"is(substr($start, 0, length(\$_ret = $end)), \$_ret);";
					} elsif($op eq "endswith") {
						"is(substr($start, -length(\$_ret = $end)), \$_ret);";
					} elsif($op eq "~") {
						"like( $start, $end );"
					} elsif($op eq "!~") {
						"unlike( $start, $end );"
					} else {
						"cmp_ok( $start, '$op', $end );";
					}
					
				};
				
				my $oper = "gt|lt|ne|eq|le|ge|==|!=|>|<|<=|>=|~|!~|startswith|endswith";
				if( s/^(.*?)[ \t]#(#)?(?:(\@|!|>>|&>)(?:[ \t]+($oper))?|($oper))?[ \t](.*)$/$replace->()/eo ) {
					push @test, $_;
					push @TEST, @test;
					@test = ();
				}
				else {
					push @test, $_;
				}
				
			}
			
		} else {
			if(@test) {
				push @TEST, @test;
				@test = ();
			}
		}
		
	}
	
	unshift @TEST, '#!/usr/bin/env perl
# сгенерировано miu
	
use Test::More tests => ' . $count_tests . ';

my ($_f, $_ret);

sub ___std {
my $fh = shift;
open $_f, ">&", $fh; close $fh; open $fh, ">", "miu-rrrumiu/miu-tmp-fh";
}

sub ___res {
my $fh = shift;
close $fh;
open $fh, ">&", $_f;
}

sub ___get {
open my $f, "miu-rrrumiu/miu-tmp-fh";
read $f, my $buf, -s $f;
close $f;
$buf
}

';
	
	print $testFile @TEST;
	
	close $testFile;
	close $articleFile;
	close $codeFile if $codeFile;
	
	close $file;
	
	$self->{count_tests} = $count_tests;
	$self
}




# тестирует указанные тесты
# возвращает 1/0 - тест прошёл-не прошёл и выводит в лог
use TAP::Parser;
sub test {
	my ($self) = @_;
	
	my $path = $self->{test_path};
	
	#for my $path (@{$self->{test_path}}) {
	#print "$path ";
	
	my $log_path = $path;
	$log_path =~ s!\.\w+$!.log!;
	open my $log, ">", $log_path or die "Не могу открыть лог $log_path: $!";
	
	my $stat_path = $path;
	$stat_path =~ s!\.\w+$!.stat!;
	open my $stat, ">", $stat_path or die "Не могу открыть лог $stat_path: $!";

	my $parser = TAP::Parser->new( {
		source => $path,
		merge => 1,
		switches => [ '-Ilib' ],
	} );
	
	my $was_fail = 0; # сброс F
	my @errors; # эксепшены
	my @fail;	# непройденные тесты
	my @FAIL;
	my @ERRORS;
	my $first;	# первый фейл или ошибка
	my $count_ok = 0; # количество пройденных тестов
	my ($count_pass, $count_tests);	# количество файлов-тестов (1) и количество всех тестов
	my $current_test;
	my $current_line;
	
	while ( my $result = $parser->next ) {
		
		######### логика
		
		if( $result->is_test ) {
			if( $result->is_ok ) {
				print "." if !$self->{log};
				$count_ok++;
			} else {
				print "E" if !$self->{log};
			}
			
			($current_test) = $result->raw =~ /(\d+)/;
			
			$current_line = $self->{lines}[$current_test];
			
			
			print "$current_line: " if $self->{log};
		}
		
		if( $result->is_comment ) {
			$first = 2 if !$first;
			push @fail, $result->raw;
		} elsif(@fail) {
			push @FAIL, [$current_line, join("\n", @fail)];
			@fail = ();
		}
		
		if( $result->is_unknown ) {
		
			push @errors, $result->raw;
			$first = 1 if !$first;
			
			if(!$was_fail) {
				print "F" if !$self->{log};
				$was_fail = 1;
			}
		} else {
			$was_fail = 0;
			
			if(@errors) {
				push @ERRORS, [$current_line, join("\n", @errors)];
				@errors = ();
			}
			
		}

		if( $result->is_plan ) {
			($count_pass, $count_tests) = split /\.\./, $result->raw;
		}
		
		
		
		######### статистика
		my @stat;
		
		if( $result->is_plan ) {
			push @stat, "is_plan ";
		}
		if( $result->is_pragma ) {
			push @stat, "is_pragma ";
		}
		if( $result->is_test ) {
			push @stat, "is_test ";
		}
		if( $result->is_comment ) {
			push @stat, "is_comment ";
		}
		if( $result->is_bailout ) {
			push @stat, "is_bailout ";
		}
		if( $result->is_version ) {
			push @stat, "is_version ";
		}
		if( $result->is_unknown ) {
			push @stat, "is_unknown ";
		}
		if( $result->is_yaml ) {
			push @stat, "is_yaml ";
		}
		if( $result->has_directive ) {
			push @stat, "has_directive ";
		}
		if( $result->has_todo ) {
			push @stat, "has_todo ";
		}
		if( $result->has_skip ) {
			push @stat, "has_skip ";
		}
	
		# по логам
		print $stat @stat if @stat;
		print $stat $result->as_string . "\n";
		print $log $result->as_string . "\n";
		
		print @stat if $self->{stat};
		print $result->as_string . "\n" if $self->{log};
	} 

	push @FAIL, [$current_line, join("\n", @fail)] if @fail;
	push @ERRORS, [$current_line, join("\n", @errors)] if @errors;
	
	close $log;
	close $stat;

	print "\n";
	
	
	
	######### сохраняем фейлы и ошибки
	$self->{fail} = [@FAIL];
	$self->{errors} = [@ERRORS];
	
	######### первая ошибка
	if(@ERRORS) {
		$_ = $ERRORS[0][1];
		if( m!\bat (.*?) line (\d+)\.! ) {
			$self->{first_error} = $` . $&;
		} else {
			$self->{first_error} = $_;
		}
	}
	
	######### обрезаем последнюю строку со статусом
	if(@FAIL) {
		@fail = split /\n/, $FAIL[$#FAIL][1];
		$self->{test_status} = pop @fail;
		$FAIL[$#FAIL][1] = join "\n", @fail;
	}
	
	if(!$self->{log}) {
		print "$self->{first_error} после строки №$ERRORS[0][0]\n" if @ERRORS && $first == 1;
		print "$FAIL[0][1]\nна строке №$FAIL[0][0]\n" if @FAIL && $first == 2;
	}
	
	$count_ok == $count_tests;
}


# публикует в интернете: хабре и т.д.
sub post {
	my ($self) = @_;
	$self
}


# обходит файлы и вызывает для каждого найденного функцию
sub find {
	my ($self, $code) = @_;
	
	my $pattern = "miu/" . ($self->{pattern} // "");
	
	my $len = length $pattern;
	my $path = $pattern =~ m!.*/!? $&: "miu";
	
	File::Find::find({
		no_chdir => 1,
		wanted => sub {
			my $path = $File::Find::name;
			return if $pattern ne substr $path, 0, $len;
			return if !-f $path;

			$code->($path);
		}
	}, $path);
	
	$self
}


# создаёт файл пакета и возвращает для записи
sub packfile {
	my ($self, $pack, $ipath) = @_;
	
	$pack =~ s!::!/!g;
	
	my $path = "lib/$pack.pm";
	
	# код-файл
	open my $codeFile, ">", $path or die "Не могу открыть файл кода $path: $!";
	
	print $codeFile "######### Файл создан автоматически miu из файла $ipath\n";
	
	$codeFile
}


# изменяет путь cygwin на виндовый
sub _winpath {
	my ($path) = @_;
	return "--undef path in winpath--" unless defined $path;
	
	local ($`, $');
	
	my $file = $path;

	if(-e $path) {
		$path = eval { require Cwd; Cwd::fast_abs_path($path) };
		$file = $path unless $@ // $!;
	}
	
	$file =~ s!^/cygdrive/(\w)!$1:!;
	$file =~ s!^/(usr/)?!c:/cygwin/!;
	$file =~ s!/!\\!g;
	$file
}