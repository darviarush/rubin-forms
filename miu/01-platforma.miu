== Платформа Web-фреймворка Rubin

=== Объект-приложение

Для библиотек фреймвока я решил сделать один главный объект, который был бы доступен во всех библиотеках через переменную `$app`.

	use R::App;

	ref $app # R::App

Через него доступны остальные библиотеки проекта. Когда на $app вызывается неизвестный метод, то он подгружает одноимённый модуль из каталога R и создаёт его экземпляр. А так же создаёт метод с таким названием, который является геттером-сеттером

	my $raise = $app->raise;
	ref $app->raise # R::Raise
	$raise ##== $app->raise
	
	$app->raise(6);
	$app->raise # 6
	
	$app->raise($raise);

	$app->raise ##== $raise
	

=== Соглашение о названиях методов

Методы в camelCase будут переводиться в R/Camel/Case.pm и Camel::Case.  
Это означает, что классы нельзя именовать в CamelCase.
	
	-e "lib/R/Async/File.pm" # 1
	ref $app->asyncFile # R::Async::File
	
=== Подсистема ошибок

R::App подключает R::Raise. R::Raise меняет $SIG{__DIE__} и $SIG{__WARN__}

	$app->raise->can('__ondie__') ## $SIG{__DIE__}
	$app->raise->can('__onwarn__') ## $SIG{__WARN__}
	


	
=== Файлы и сокеты

Фреймворк Rubin использует легковесные процессы основанные на сопрограммах (coroutine). В perl они представлены модулем **Coro**.

Переключение между легковесными процессами происходит при ожидании файлов и сокетов. Это означает, что операции ввода-вывода должны быть неблокирующими.

<div class=warn>Используйте для блокирующих операций отдельные процессы и не применяйте `sleep`. Вместо `sleep` используйте таймеры.</div>

Для работы с такими файлами в $app сделан отдельный метод file, который создаёт новый файл или множество файлов:

	use R::App;

	ref $app->file("1") # R::Async::File
	ref $app->file("2", "3") # R::Async::Fileset

Файл открывается при первой операции ввода-вывода:

	$f1 = $app->file("misc/t/1.txt")->mkpath0;
	# mkpath0 тут создал каталоги misc и misc/t, если тех не существовало ранее
	-e "misc/t" # 1
	
	$f1->write("123")->close;
	
	$f2 = $app->file($f1->path);
	
	$f2->read();	# 123
	
Файл закрывается деструктором, когда на его объект исчезнут все ссылки. Ну или методом `close`
	
То же, но с объединённым вводом-выводом:

	use R::App;

	$f1 = $app->file("misc/t/1.txt")->open("w+");

	$f1->fh	#startswith *IO::AIO::fd#

	$f1->read	## ""

	$f1->write("123\n")->write("456\n");

	$f1->seek(0);

	$f1->read(3)	# 123
	$f1->read(5)	# \n456\n
	
	$f1->read(6)	## ""

	$f1->seek(0);

	$f1->readln()	# 123
	$f1->readline()	# 456\n

	$f1->close;
	

==== Поиск файлов

Поиск среди файлов осуществляется методом find.
Он ищет hекурсивно во всех вложенных директориях.

$app->find()



==== watch

Метод watch следит и при изменении вызывает callback, указанный методом then.

