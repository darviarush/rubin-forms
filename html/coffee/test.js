// Generated by CoffeeScript 1.7.1
var css_calendar,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CTest.category("Расширения встроенных классов");

new CTest('key-CFunction-implements', "`implements Class` - переписывает методы из указанного класса", function() {
  var ExImplemented, ex;
  ExImplemented = (function() {
    function ExImplemented() {}

    ExImplemented["implements"](CNode, {
      constructor: 'const1'
    });

    return ExImplemented;

  })();
  ex = new ExImplemented();
  ex.const1(document.createTextNode("ps"));
  this.is("ps", ex.val());
  ExImplemented = (function() {
    function ExImplemented() {}

    ExImplemented.implements_own(CNode);

    return ExImplemented;

  })();
  ex = new ExImplemented;
  this.ok(ex.text);
  return this.ok(!ex.wrap);
});

CTest.category("эффекты");

new CTest('key-CEffect-fadeIn', "`fadeIn` - эффект проявления элемента\n\nОснован на прозрачности. Используется как: `@morph 'fadeIn'`\n\nСм. #fadeOut", "<div id=$name class=test-square></div>", function() {
  this.count(1);
  this.w().on('click', function() {
    return this.morph({
      effect: 'fadeIn',
      timeout: 'fast'
    });
  });
  return this.w().morph({
    effect: 'fadeIn',
    timeout: 'fast',
    end: (function(_this) {
      return function() {
        return _this.ok(1);
      };
    })(this)
  });
});

new CTest('key-CEffect-fadeOut', "`fadeOut` - эффект затухания элемента\n\nОснован на прозрачности. Используется как: `@morph 'fadeOut'`\n\nСм. #fadeOut", "<div id=$name class=test-square></div>", function() {
  var self;
  this.count(1);
  self = this;
  this.w().on('click', function() {
    return this.morph({
      effect: 'fadeOut',
      timeout: 'fast',
      end: function() {
        return this.show();
      }
    });
  });
  return this.w().morph({
    effect: 'fadeOut',
    timeout: 'fast',
    end: function() {
      this.show();
      return self.ok(1);
    }
  });
});

new CTest('key-CEffect-show', "`show` - эффект появления элемента\n\nОснован на размере шрифта и ширине. Используется как: `@morph 'show'`\n\nСм. #fadeOut", "<div id=$name class=test-square>Show is very</div>", function() {
  this.count(1);
  this.w().on('click', function() {
    return this.morph({
      effect: 'show',
      timeout: 'fast'
    });
  });
  return this.w().morph({
    effect: 'show',
    timeout: 'fast',
    end: (function(_this) {
      return function() {
        return _this.ok(1);
      };
    })(this)
  });
});

new CTest('key-CEffect-hide', "`hide` - эффект ищезания элемента\n\nОснован на прозрачности. Используется как: `@morph 'hide'`\n\nСм. #fadeOut", "<div id=$name class=test-square>Hide is very</div>", function() {
  var self;
  this.count(1);
  self = this;
  this.w().on('click', function() {
    return this.morph({
      effect: 'hide',
      timeout: 'fast',
      end: function() {
        return this.show();
      }
    });
  });
  return this.w().morph({
    effect: 'hide',
    timeout: 'fast',
    end: function() {
      this.show();
      return self.ok(1);
    }
  });
});

new CTest('key-CEffect-slideUp', "`slideUp` - эффект развёртывания элемента\n\nОснован на высоте. Используется как: `@morph 'slideUp'`\n\nСм. #fadeOut", "<div id=$name class=test-square>slideUp is very</div>", function() {
  this.count(1);
  this.w().on('click', function() {
    return this.morph({
      effect: 'slideUp',
      timeout: 'fast'
    });
  });
  return this.w().morph({
    effect: 'slideUp',
    timeout: 'fast',
    end: (function(_this) {
      return function() {
        return _this.ok(1);
      };
    })(this)
  });
});

new CTest('key-CEffect-slideDown', "`slideDown` - эффект свёртывания элемента\n\nОснован на высоте. Используется как: `@morph 'slideDown'`\n\nСм. #fadeOut", "<div id=$name class=test-square>slideDown is very</div>", function() {
  var self;
  this.count(1);
  self = this;
  this.w().on('click', function() {
    return this.morph({
      effect: 'slideDown',
      timeout: 'fast',
      end: function() {
        return this.timeout(500, function() {
          return this.show();
        });
      }
    });
  });
  return this.w().morph({
    effect: 'slideDown',
    timeout: 'fast',
    end: function() {
      self.ok(1);
      return this.timeout(500, function() {
        return this.show();
      });
    }
  });
});

CTest.category("потоки");

new CTest("cls-CStream", "`CStream` - класс реактивного программирования (FRP)", "#%name-plus, #%name-minus, #%name-result { text-align: center; display: inline-block; width: 100px; border: solid 1px orange; color: white}\n\n#%name-plus, #%name-minus { background: brown; cursor: pointer}\n\n#%name-result { background: SlateGrey; }", "<div id=$name-plus>1</div>\n<div id=$name-minus>-1</div>\n<div id=$name-result></div>", function() {
  var merge, minus, plus, result;
  plus = this.w("plus").stream("click").map(1);
  minus = this.w("minus").stream("click").map(-1);
  merge = plus.merge(minus);
  result = merge.reduce(5, function(a, b) {
    return a + b;
  });
  result.assign(this.w("result"), "text");
  this.w("plus").fire("click");
  this.is("6", this.w("result").text());
  this.w("minus").fire("click");
  this.is("5", this.w("result").text());
  minus.emit();
  return this.is("4", this.w("result").text());
});

new CTest("obj-CStream-meta", "`meta emitFunction, [param]` - создаёт новое звено потока\n\nМетод `meta` создаёт экземпляр `CStream`, добавляет его в свойство `@fork`, устанавливает ему функцию реагирующую на данные, движущиеся по потоку и параметры, и возвращает.\n\nСм. #maps, #mapAll", function() {
  var s, self;
  this.count(4);
  self = this;
  (s = new CStream).meta(function(channel) {
    self.is(channel.args[0], 30);
    channel.src = {
      hi: "hello!"
    };
    channel.args = [10, 20];
    return this.send(channel);
  }).then(function(x, y) {
    self.is(this.hi, "hello!");
    self.is(x, 10);
    return self.is(y, 20);
  });
  return s.emit(30);
});

new CTest("obj-CStream-emitter", "`emitter` - возвращает замыкание с этим потоком, которое используется как слушатель\n\nАргументы переданные при вызове замыкания передаются далее по потоку, так же как и объект вызвавший замыкание.\nОт имени этого объекта и вызываются все функции установленные в потоке\n", function() {
  var fn, stream;
  this.count(1);
  stream = new CStream;
  fn = stream.emitter();
  stream.then(function(val) {
    return this.is(val, 6);
  });
  return fn.call(this, 6);
});

new CTest("obj-CStream-map", "`map fn|arg, args...` - замещает передающиеся по потоку аргументы на значение возвращённое функцией fn, либо устанавливает аргументы\n\nСм. #maps, #mapAll", function() {
  var stream;
  this.count(4);
  (stream = new CStream).map(10, 12).then((function(_this) {
    return function(arg1, arg2) {
      _this.is(arg1, 10);
      return _this.is(arg2, 12);
    };
  })(this));
  stream.emit();
  (stream = new CStream).map((function() {
    return 13;
  }), 12).then((function(_this) {
    return function(arg1) {
      _this.is(arg1, 13);
      return _this.is(arguments.length, 1);
    };
  })(this));
  return stream.emit(20, 30);
});

new CTest("obj-CStream-flatMap", "`flatMap fn` - заменяет поток на возвращённый функцией fn\n\nСм. #merge, #combine", function() {
  var self, stream;
  self = this;
  this.count(2);
  CStream.prototype.exMap = function(f) {
    return this.flatMap(function(x) {
      return CStream.unit(f(x));
    });
  };
  CStream.prototype.exFilter = function(f) {
    return this.flatMap(function(x) {
      if (f(x)) {
        return CStream.unit(x);
      } else {
        return CStream.nothing();
      }
    });
  };
  (stream = new CStream).exMap(function(x) {
    return x + 3;
  }).then(function(v) {
    return this.is(v, 13);
  });
  stream.emits(this, 10);
  (stream = new CStream).exFilter(function(x) {
    return x === 10;
  }).then(function(v) {
    return this.is(v, 10);
  });
  stream.emits(this, 10);
  (stream = new CStream).exFilter(function(x) {
    return x !== 10;
  }).then(function(v) {
    return this.ok(false);
  });
  return stream.emits(this, 10);
});

new CTest("obj-CStream-combine", "`combine streams..., [fn]` - комбинирует несколько потоков в один\n\n- fn args, channel - функция для комбинации. Получает массив [{src: this, args: аргументы}...] и последние пришедшие данные (channel), которые есть и в массиве. Должна вернуть {src: ..., args: ...}\n\nСм. #merge, #zip", function() {
  var k, s, s1, s2, s3;
  this.count(2);
  s1 = new CStream();
  s2 = new CStream();
  s3 = new CStream();
  s = s1.combine(s2, s3);
  k = s1.combine(s2, s3, function(args, channel) {
    var ch;
    return {
      src: channel.src,
      args: (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          ch = args[_i];
          _results.push(ch.args[1]);
        }
        return _results;
      })()
    };
  });
  s.then(function() {
    var x;
    x = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.is(String(x), "10,20,30");
  });
  k.then(function() {
    var x;
    x = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.is(String(x), "0,1,2");
  });
  s1.emit(10, 0);
  s2.emit(20, 1);
  return s3.emits(this, 30, 2);
});

new CTest("obj-CStream-zip", "`zip n, [fn]` - собирает n отправок в массив, который и отправляет дальше\n\n- n - может быть числом, функцией или строкой. Если это число, то собирает n отправок в массив\n- - Если функция, то отправляет \n- - Если строка, то собирает отправки в течение указанного времени, после прихода первой посылки\n- fn args, channel - функция для комбинации. Получает массив [{src: this, args: аргументы}...] и последние пришедшие данные (channel), которые есть и в массиве. Должна вернуть {src: ..., args: ...}\n\nСм. #merge, #combine", function() {
  var s, x;
  this.count(6);
  s = new CStream;
  s.zip(2).then(function(x, y) {
    this.is(x, 10);
    return this.is(y, 20);
  });
  s.zip(function(args) {
    return args.length === 3;
  }).then(function(x, y, z) {
    this.is(x, 10);
    this.is(y, 20);
    return this.is(z, 6);
  });
  s.zip("30ms").then(function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.is(String(args), "10,20,6");
  });
  (x = CStream.sleep(10)).then(function() {
    return s.emits(this, 6);
  });
  x.emits(this);
  s.emit(10);
  return s.emits(this, 20);
});

new CTest("obj-CStream-repeat", "`repeat n, [ms], [map]` - повторяет данные n раз через ms миллисекунд\n\n- n - номер\n- n - объект - должен содержать from, to, by. from и by - необязательны. Заполняются 0-м и 1-й соотвестственно\n- ms - интервал в миллисекундах между повторениями\n- map - если положителен, то итератор будет мапиться\n\nСм. #serial, #from", function() {});

new CTest("obj-CStream-serial", "`serial serial, [ms]` - отправляет элементы серии через ms миллисекунд\n\n- serial - номер\n- serial - объект - должен содержать from, to, by. from и by - необязательны. Заполняются 0-м и 1-й соотвестственно. Аналог #repeat с установленным параметром ''map''\n- serial - массив - отправляет по одному\n- ms - интервал в миллисекундах между отправками\n\nСм. #repeat, #from", function() {
  return CStream.serial([10, 20]).then(function(x) {});
});

new CTest("obj-CStream-from", "`from n, [ms]` - повторяет данные n раз через ms миллисекунд\n\n- n - массив - отправляет элементы один за другим\n- n - объект - отправляет каждое ключ-значение в виде массива [key, val] \n- ms - интервал в миллисекундах между отправками\n\nСм. #repeat, #serial", function() {
  return CStream.from([10, 20]).then(function(x) {});
});

CTest.category("модель");

new CTest("cls-CModel", "`CModel properties, compares` - модель имеет свойства и вызывает обработчики событий, если свойство изменилось\n\nТак же модель может обновить свойство, если его запросили\n\nУ всех экземпляров класса CWidget или его наследников есть свойство model, которое представляет главную модель\n\n- properties - ключ-значения, где ключ соответствуют названию свойства модели, а значение - начальному значению этого свойства\n- compares - функции сравнения. Когда приходит новое значение, то оно сравнивается со старым - если оно не изменилось, то и обработчики не изменяются. Если функция сравнения не указано, то используется жёсткое сравнение javascript (===)\n\nСм. #CRouter", "<div id=$name ctype=form>\n	<p>Имя: <input id=$name-input model=name>\n	<span id=$name-span model=name></span><br>\n	То же имя: <input id=$name-i2 model=name></p>\n	<p>Фамилия: <input id=$name-family model=family></p>\n	<p>Имя и фамилия: <span id=$name-fio model=fullName></span></p>\n</div>", function() {
  var w;
  w = this.w();
  this.w("input").val("Hello");
  this.w("input").fire("keyup");
  this.is(this.w("span").text(), "Hello");
  this.is(this.w("i2").text(), "Hello");
  this.is(this.w("fio").text(), "");
  w.model.compute("fullName", function(name, family) {
    return name + ' ' + family;
  });
  w.model.family("World!");
  this.is(w.model.family(), "World!");
  this.is(this.w("family").text(), "World!");
  return this.is(this.w("fio").text(), "Hello World!");
});

new CTest("obj-CModel-compute", "`compute key, fn|options` - создаёт вычислимое свойство на модели или заменяет его\n\n- key - имя свойства\n- fn - функция чтения из свойства\n- options\n- - slave - зависимая от других свойств функция. Её параметры должны быть именами свойств от которых она зависит\n- - master - функция записи в свойство\n- - cmp - функция сравнения\n- - val - начальное значение\n\nСм. #set, #del", "<div id=$name ctype=form>\n	<input id=$name-name model=name>\n	<input id=$name-family model=family>\n	<input id=$name-fullname model=fullname>\n</div>", function() {
  var model;
  this.w();
  model = CRoot.model.compute('fullname', {
    slave: function(name, family) {
      return name + ' ' + family;
    },
    master: function(val, old, key) {
      var match;
      match = val.match(/^(\S+)\s+(.+)/);
      this.name(match[1]);
      return this.family(match[2]);
    },
    val: "abc"
  }).name('Юля').family('Малышева');
  this.is(this.w("fullname").text(), 'Юля Малышева');
  this.w("fullname").text('Вадим Дубровный').fire('keyup');
  this.is(this.w("name").text(), 'Вадим');
  return this.is(this.w("family").text(), 'Дубровный');
});

new CTest("obj-CModel-set", "`set key, [val], [cmp]` - создаёт или заменяет свойство на модели\n\n- key - имя свойства\n- val - начальное значение\n- cmp - функция сравнения\n\nСм. #compute, #del, #has", function() {
  var model;
  model = CRoot.model;
  this.ok(!model.has("test_key"));
  model.set("test_key", "abc");
  return this.ok(model.has("test_key"));
});

new CTest("obj-CModel-has", "`has key` - определяет, есть ли в модели свойство key\n\n- key - имя свойства\n\nСм. #set, #compute", function() {
  var model;
  model = CRoot.model.set('test_has');
  this.ok(!model.has("test_key-xxx"));
  return this.ok(model.has("test_has"));
});

new CTest("obj-CModel-on", "`on key, observe` - ставит обозреватель на свойство key\n\n- key - имя свойства\n- observe - функция-обозреватель\n\nСм. #off, #at", function() {
  this.count(3);
  return CRoot.model.set('test_on', "abc").on('test_on', (function(_this) {
    return function(val, old, key) {
      _this.is(val, "a");
      _this.is(old, "abc");
      return _this.is(key, "test_on");
    };
  })(this)).test_on("a");
});

new CTest("obj-CModel-off", "`off key, [observe]` - удаляет обозреватель или все обозреватели со свойства key\n\n- key - имя свойства\n- observe - функция-обозреватель или свойство _belong обозревателя (не может быть функцией)\n\nСм. #off, #at", function() {
  var fn, model;
  model = CRoot.model.set('test_off');
  model.on("test_off", fn = function() {});
  this.is(model._on.test_off[0], fn);
  model.off("test_off", fn);
  this.ok(!model._on.test_off);
  model.on("test_off", fn = function() {});
  fn._belong = 'что-то';
  model.off("test_off", 'что-то');
  return this.ok(!model._on.test_off);
});

new CTest("obj-CModel-at", "`at key, observe` - ставит обозреватель запроса на свойство key\n\nВ отличие от #on обозреватель сработает при чтении из свойства\n\n- key - имя свойства\n- observe - функция-обозреватель\n\nСм. #off, #at", function() {
  this.count(3);
  CRoot.model.set('test_at', 'a').at('test_at', (function(_this) {
    return function(key, val) {
      _this.is(key, "test_at");
      _this.is(val, "a");
      return "b";
    };
  })(this));
  return this.is(CRoot.model.test_at(), "b");
});

new CTest("obj-CModel-un", "`un key, [observe]` - удаляет обозреватель запроса или все обозреватели со свойства key\n\n- key - имя свойства\n- observe - функция-обозреватель или свойство _belong обозревателя (не может быть функцией)\n\nСм. #off, #at", function() {
  var fn, model;
  this.count(0);
  model = CRoot.model.set("test_key");
  model.at("test_key", fn = function() {
    return this.ok(false);
  });
  model.un(fn);
  return model.test_key(1);
});

new CTest("obj-CModel-del", "`del key` - удаляет свойство key\n\n- key - имя свойства\n\nСм. #set, #compute, #has", function() {
  var model;
  model = CRoot.model;
  model.set("test_key");
  model.on('test_key', function() {});
  model.at('test_key', function() {});
  model.compute("test_key", function(x, y) {});
  this.ok(model._on.x);
  this.ok(model._on.y);
  model.del("test_key");
  this.ok(!model.has("test_key"));
  this.ok(!model._on.test_key);
  this.ok(!model._at.test_key);
  this.ok(!model._on.x);
  return this.ok(!model._on.y);
});

new CTest("obj-CModel-cmp", "`cmp key, [fn|null]` - устанавливает или возвращает функцию сравнения", function() {});

CTest.category("служебные методы");

new CTest('cls-CWidget', "`CWidget element, [parent]` - класс виджет\n\nelement - элемент который оборачивается виджетом\nparent - виджет, который будет главным над этим\n\nПорождает циклическую ссылку\n\nСм. #CFormWidget", function() {
  var e, w;
  this.count(3);
  try {
    new CWidget;
  } catch (_error) {
    e = _error;
    this.ok(1);
  }
  e = document.createElement('div');
  w = new CWidget(e);
  this.is(w.element, e);
  return this.is(e.widget, w);
});

new CTest('obj-CWidget-raise', "`raise message` - создаёт экземпляр исключения Error, добавляя к нему объект в котором произошло исключение и stack trace\n\nИспользовать: `throw @raise \"сообщение\"`", function() {
  return this["instanceof"](CRoot.raise("Исключение"), Error);
});

new CTest('obj-CWidget-warn', "`warn message...` - выводит отладочную информацию в console.log. Практически не используется, т.к. функция say предоставляет весь необходимый для этого функционал", function() {
  return this.ok(CRoot.warn);
});

new CTest('obj-CWidget-className', "`className` - возвращает строку с именем класса виджета. Так у экземпляра CWidget это будет \"CWidget\"", function() {
  this.is(CRoot.className(), "CRoot$");
  this.is($("1").className(), "CNode");
  this.is($("<div></div>").className(), "CWidget");
  this.is($("123<div></div>").className(), "CWidgets");
  return this.is($("").className(), "CWidgets");
});

CTest.category("методы создания элементов и виджетов");

new CTest('obj-CWidget-wrap', "`wrap array|element|string|number|widget|null, [parent]` - создаёт на основе своего аргумента виджет. Если аргументом является виджет или элемент имеющий виджет, то возвращается этот виджет. Возвращает или виджет или коллекцию, если же аргумент undefined или null - то null\n\n2. parent - родительский виджет для порождённого виджета. Родительский виджет, это форма, она позволяет устанавливать обработчики на свои элементы.\n\nСм. #createWidget, #CFormWidget", function() {
  var w;
  w = CRoot;
  this.is(w.wrap("<td></td>").element.tagName, 'TD');
  this.is(w.wrap(null), null);
  this.is(w.wrap(10).element.nodeType, 3);
  this.is(w.wrap('#obj-CWidget-wrap').element.data, '#obj-CWidget-wrap');
  this["instanceof"](w.wrap([]), CWidgets);
  this.is(w.wrap([['<i>1</i>', 2, 3], [4, 5]]).length, 5);
  this.is(w.wrap([['<i>1</i>', 2, 3], [4, 5]]).item(4).text(), "5");
  this.is(w.wrap("<div></div>").wrap(/body/).tag(), "BODY");
  return this.is(w.wrap("").wrap(/body/).tag(), "BODY");
});

new CTest('obj-CWidget-unwrap', "`unwrap` - отключает обёртку CWidget от элемента и элемент от обёртки. Возвращает коллекцию с элементом. В коллекции - отключает все подключённые элементы и возвращает себя", function() {
  var e, w;
  w = CRoot.wrap("<div></div>");
  this["instanceof"](w.element.widget, CWidget);
  e = w.element;
  w.unwrap();
  this.is(w.element, null);
  return this.is(e.widget, null);
});

new CTest('obj-CWidget-rewrap', "`rewrap cls|widget` - меняет обёртку виджета на вновь созданный виджет указанного класса или на виджет", function() {
  var e, w, w1;
  w = $("<div></div>");
  this["instanceof"](w.element.widget, CWidget);
  e = w.element;
  w = w.rewrap(CNode);
  this["instanceof"](w, CNode);
  this.is(w.element, e);
  this.is(e.widget, w);
  w1 = $("<div></div>");
  this.is(w1, w.rewrap(w1));
  this.is(w1.element, e);
  return this.is(w.element, null);
});

new CTest('obj-CWidget-createWidget', "`createWidget element, [cls], [parent]` - определяет класс виджета и создаёт его. Возвращает созданный виджет. Если у элемента уже есть виджет - возвращает его. При этом cls и parent - игнорируются", function() {
  var div;
  div = document.createElement('div');
  div.setAttribute('ctype', 'img');
  return this.is(CRoot.createWidget(div).className(), 'CImgWidget');
});

new CTest('obj-CWidget-ctype', "`ctype element` - возвращает класс элемента", function() {
  var div;
  div = document.createElement('div');
  div.setAttribute('ctype', 'img');
  return this.is(CRoot.ctype(div), CImgWidget);
});

new CTest('obj-CWidget-new', "`new tag, [ctype|cls], [attr]` - создаёт элемент и оборачивает его в виджет\n\n- ctype - строка с названием класса виджета\n- cls - класс виджета\n- attr - хеш с атрибутами, которые будут установлены до обёртки элемента в виджет\n\nСм. #wrap, #xml, #svg, #createWidget, #CFormWidget", function() {
  var w;
  this["instanceof"](CRoot["new"]("div"), CWidget);
  this["instanceof"](CRoot["new"]("div", "input"), CInputWidget);
  this["instanceof"](CRoot["new"]("div", CFormWidget, {
    id: 'ex-test'
  }), CFormWidget);
  w = CRoot["new"]("div", {
    ctype: "form",
    id: 'ex-test',
    action: "/test"
  });
  this["instanceof"](w, CFormWidget);
  return this.is(w.attr("action"), "/test");
});

CTest.category("служебные елементы");

new CTest('obj-CWidget-document', "`document` - возвращает документ в который вставлен элемент или null, если элемент виджета не принадлежит ни одному документу.\nНужен во фреймах", function() {
  return this.is(CRoot.document(), document);
});

new CTest('obj-CWidget-window', "`window` - возвращает окно в который вставлен элемент или null, если элемент виджета не принадлежит ни одному окну.\nНужен во фреймах", function() {
  return this.is(CRoot.window(), window);
});

new CTest('obj-CWidget-htm', "`htm` - возвращает виджет html-элемента", function() {
  this.is(CRoot, CRoot.htm());
  return this.is(CRoot.tag(), 'HTML');
});

new CTest('obj-CWidget-root', "`root` - возвращает корневой виджет для документа (Chrome) или иерархии DOM (FF) в котором находится элемент", function() {
  var div, div2;
  this.is(CRoot, CRoot.root());
  div = document.createElement('div');
  div2 = document.createElement('div');
  div.appendChild(div2);
  return this.is(new CWidget(div2).root().element, div);
});

new CTest('obj-CWidget-viewport', "`viewport` - возвращает виджет элемента на котором находится прокрутка окна, это html или, в некоторых браузерах, body", function() {
  return this.ok(CRoot.viewport().vscroll('size'));
});

new CTest('obj-CWidget-body', "`body` - возвращает виджет элемента body", function() {
  return this.ok(CRoot.body().element, document.body);
});

new CTest('obj-CWidget-head', "`body` - возвращает виджет элемента head", function() {
  return this.ok(CRoot.head().element, document.getElementsByTagName("head")[0]);
});

CTest.category("методы изменения строки url браузера");

new CTest('obj-CWidget-navigate', "`navigate [go], [url, [title, [data]]]` - изменяет историю переходов браузера. Без параметров возвращает [url, title, data]\n\n2. если первый параметр - ноль (go), то заменяет текущий элемент истории на указанный последующими параметрами\n3. если первый параметр - цифра, то переходит по истории вперёд или назад\n1. иначе добавляет новый элемент истории\n", function() {
  var data, title, url, _ref;
  _ref = CRoot.navigate(), url = _ref[0], title = _ref[1], data = _ref[2];
  this.is(window.history$.length, 1);
  this.is(window.history_pos$, 0);
  this.is(CRoot, CRoot.navigate('/example/navigate', 'Эксперимент', {
    ex: 10
  }));
  this.is(window.history$.length, 2);
  this.is(window.history_pos$, 1);
  this.like(CRoot.navigate()[0], /\/example\/navigate$/);
  this.is(CRoot.navigate()[1], 'Эксперимент');
  this.is(CRoot.navigate()[2].ex, 10);
  this.is(CRoot, CRoot.navigate(0, url, title, data));
  this.is(window.history$.length, 2);
  this.is(window.history_pos$, 1);
  this.is(CRoot.navigate()[0], url);
  return this.is(CRoot.navigate()[1], title);
});

CTest.category("методы работы с cookie");

new CTest('obj-CWidget-cookie', "`cookie name, [value, [properties]]` - возвращает или устанавливает куку. Если val равен null, то удаляет куку. Если не указана опция path, то устанавливает куку для всех страниц сайта", function() {
  CRoot.cookie("bsd", null);
  this.ok(CRoot.cookie("bsd") == null);
  this.is(CRoot, CRoot.cookie("bsd", "value"));
  this.is("value", CRoot.cookie("bsd"));
  CRoot.cookie("bsd", null);
  return this.ok(CRoot.cookie("bsd") == null);
});

CTest.category("методы установки обработчиков");

new CTest('obj-CWidget-send', "`send type, args...` - отправляет событие виджетов паренту. Если парента нет - то себе\n\n#Send.setHandler", "<div id=ExSend>\n	<div id=ExSend-fld>_</div>\n</div>", function() {
  var ExSend, ex, test;
  this.count(3);
  test = this;
  ExSend = (function(_super) {
    __extends(ExSend, _super);

    function ExSend() {
      return ExSend.__super__.constructor.apply(this, arguments);
    }

    ExSend.prototype.fld_onclick = function(param, fld) {
      test.is(fld, this.fld);
      return test.is(param, 22);
    };

    return ExSend;

  })(CFormWidget);
  ex = new ExSend;
  this.like(/CSend/, ex.fld.attr('onclick'));
  return ex.fld.send('onclick', 22);
});

new CTest("obj-CWidget-on", "`on type, listen, [phase]` - ставит обработчик на события\n\n- type - названия одного или нескольких событий. Без префикса \"on\"\n- listen - функция-обработчик\n- phase - фаза - добавить в конец или в начало очереди обработчиков. По умолчанию - в конец\n\nСм. #one, #off", function() {
  var w;
  this.count(2);
  w = CRoot["new"]('div');
  w.on('MyEvent1 MyEvent2', (function(_this) {
    return function(a) {
      return _this.is(a, 10);
    };
  })(this));
  w.send('onMyEvent1', 10);
  return w.send('onMyEvent2', 10);
});

new CTest("obj-CWidget-off", "`off type, [listen], [phase]` - ставит обработчик на события\n\n- type - названия одного или нескольких событий. Без префикса \"on\"\n- listen - функция-обработчик или значение свойства _belong функции-обработчика. Если не указан - удаляется. _belong не может быть функцией\n- phase - фаза - удалять из конеца или из начала очереди обработчиков. По умолчанию - из конца\n\nСм. #one, #off", function() {
  var fn1, fn2, fn3, w;
  w = CRoot["new"]('div');
  w.on('MyEvent1', fn1 = function() {});
  w.on('MyEvent1', fn2 = function() {});
  w.on('MyEvent1', (fn3 = function() {}), 1);
  this.is(w._sendQueue.onMyEvent1[0], fn3);
  this.is(w._sendQueue.onMyEvent1[1], fn1);
  this.is(w._sendQueue.onMyEvent1[2], fn2);
  w.on('MyEvent1', fn3);
  this.is(w._sendQueue.onMyEvent1[3], fn3);
  w.off('MyEvent1', fn3, 1);
  this.is(w._sendQueue.onMyEvent1[0], fn1);
  fn3._belong = 6;
  w.off('MyEvent1', 6);
  this.is(w._sendQueue.onMyEvent1.length, 2);
  this.is(w._sendQueue.onMyEvent1[0], fn1);
  return this.is(w._sendQueue.onMyEvent1[1], fn2);
});

new CTest("obj-CWidget-one", "`one type, listen, [phase]` - ставит обработчик на события, аналогично #on. Но как только обработчик выполниться на событии он сразу же удаляется", function() {
  var w;
  this.count(2);
  w = CRoot["new"]('div');
  w.one('MyEvent1 MyEvent2', (function(_this) {
    return function(a) {
      return _this.is(a, 10);
    };
  })(this));
  w.send('onMyEvent1', 10);
  w.send('onMyEvent2', 10);
  w.send('onMyEvent1', 20);
  return w.send('onMyEvent2', 20);
});

new CTest('obj-CWidget-defineHandlers', "`defineHandlers` - пробегает по всем методам объекта и запоминает методы-события\n\n* методы начинающиеся на on и записанные буквами нижнего регистра - устанавливаются на элемент: onclick, onchange\n* начинающиеся на имя элемента формы - используется формами (CForm): bt_onclick\n* формы могут быть вложенными: `form2__form3__bt_onclick`\n* заканчивающиеся на описатель: onscroll_window, onload_window, onmouseleave_parent\n\nСм. #setHandler, #send, #getHandlersOnElements, #setListens", function() {
  var ex;
  window.Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.onclick = function() {};

    Ex.prototype.bt_onclick = function() {};

    Ex.prototype.form2__form3__bt_onclick = function() {};

    Ex.prototype.onscroll_window = function() {};

    return Ex;

  })(CWidget);
  ex = $("<div ctype=Ex></div>");
  ex.defineHandlers();
  this.is(Ex.selfHandlers[0], "click");
  this.is(Ex.handlers.bt["@"]["click"], "bt_onclick");
  this.is(Ex.handlers.form2.form3.bt["@"]["click"], "form2__form3__bt_onclick");
  this.is(Ex.listens.onscroll_window[0], "window");
  return this.is(Ex.listens.onscroll_window[1], "scroll");
});

new CTest('obj-CWidget-setHandler', "`setHandler handlers...` - устанавливает собственные события, переданные списком параметров\n\nСм. #setHandlers, #defineHandlers, #send, #getHandlersOnElements, #setListens", function() {
  return this.like($("<div></div>").setHandler("click").attr("onclick"), /CSend/);
});

new CTest('obj-CWidget-setHandlers', "`setHandlers` - устанавливает события класса формата on[a-z]+\n\nСм. #setHandlers, #defineHandlers, #send, #getHandlersOnElements, #setListens", function() {
  window.Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.onclick = function() {};

    return Ex;

  })(CWidget);
  return this.like($("<div ctype=Ex></div>").defineHandlers().setHandlers().attr("onclick"), /CSend/);
});

new CTest('obj-CWidget-setHandlersOnElements', "`setHandlersOnElements` - устанавливает хандлеры на элементов формы. В поиске таких хандлеров проходит по парентам (вышестоящим формам)", function() {
  var w;
  window.Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.form2__bt_onclick = function() {};

    Ex.prototype.fld_onclick = function() {};

    return Ex;

  })(CFormWidget);
  w = $("<div id=ex ctype=Ex><span id=ex-fld></span></div>");
  this.like($("<div id=ex ctype=Ex><span id=ex-fld></span><div id=ex-form2 ctype=form><span id=ex-form2-bt></span></div></div>").form2.bt.attr("onclick"), /CSend/);
  window.Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.bt_onclick = function() {};

    return Ex;

  })(CWidget);
  w = $("<div id=ex ctype=Ex><span id=ex-bt></span></div>").defineHandlers().setHandlersOnElements();
  return this.like(w.first().attr("onclick"), /CSend/);
});

new CTest('obj-CWidget-setListens', "`setListens` - устанавливает описатели определённые defineHandlers на окно, parent и т.д.", function() {
  var self, w;
  this.count(1);
  self = this;
  window.Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.onresize_window = function() {
      $(window).off('resize', this);
      return self.ok(1);
    };

    return Ex;

  })(CWidget);
  w = $("<div ctype=Ex></div>").defineHandlers().setListens();
  $(window).fire('resize');
  return $(window).fire('resize');
});

new CTest('obj-CWidget-observe', "`observe method, before, [after], [phase]` - заменяет указанный метод в объекте на замыкание, которое возбуждает исключения и onBeforeMethod и onMethod. На них и устанавливаются обработчики\n\n- обработчик before срабатывает перед методом, а обработчик after - после\n- обработчик after получает первым параметром результат метода, а затем - его параметры\n\nУдалить обсерверы можно методом #shut.\n\nСм. #shut", function() {
  var Ex, after, before, ex, onExAfter, onExAfter2, onExBefore, onExBefore2;
  before = after = 0;
  Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.method = function(a, b) {
      return 22 + a * b;
    };

    return Ex;

  })(CWidget);
  onExBefore = function(a, b) {
    return before += a;
  };
  onExAfter = function(ret, a, b) {
    return after += b;
  };
  onExBefore2 = function(a, b) {
    return before -= a * 2;
  };
  onExAfter2 = function(ret, a, b) {
    return after -= b * 2;
  };
  ex = new Ex(document.createElement('div'));
  ex.observe('method', onExBefore);
  ex.observe('method', null, onExAfter);
  ex.observe('method', onExBefore2, onExAfter2);
  this.is(ex.method(2, 3), 28);
  this.is(before, -2);
  return this.is(after, -3);
});

new CTest('obj-CWidget-shut', "`shut method, [observer]` - удаляет обработчики установленные методом #observer\n\nСм. #observer", function() {
  var Ex, after, before, ex, onExAfter, onExAfter2, onExBefore, onExBefore2;
  before = after = 0;
  Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.method = function(a, b) {
      return 22 + a * b;
    };

    return Ex;

  })(CWidget);
  onExBefore = function(a, b) {
    return before += a;
  };
  onExAfter = function(ret, a, b) {
    return after += b;
  };
  onExBefore2 = function(a, b) {
    return before -= a;
  };
  onExAfter2 = function(ret, a, b) {
    return after -= b;
  };
  ex = new Ex(document.createElement('div'));
  ex.observe('method', onExBefore, onExAfter);
  ex.observe('method', onExBefore2, onExAfter2);
  this.is(ex.method(2, 3), 28);
  this.is(before, 0);
  this.is(after, 0);
  ex.shut('method', onExBefore);
  this.is(ex.method(2, 3), 28);
  this.is(before, -2);
  this.is(after, 0);
  ex.shut('method');
  this.is(ex.method(2, 3), 28);
  this.is(before, -2);
  return this.is(after, 0);
});

new CTest('obj-CWidget-listen', "`listen type, fn, [fase]` - устанавливает обработчик на виджет, используя обычный addEventListener. Использовать нерекомендуется. Лучше использовать стандартный механизм фреймворка - методы начинающиеся на \"on\"", "<select id=$name></select>", function() {
  var test;
  test = 1;
  this.w().listen("click", function() {
    return test = 10;
  }).fire("click");
  return this.is(test, 10);
});

new CTest('obj-CWidget-drop', "`drop type, fn, [fase]` - удаляет обработчик установленный listen", "<select id=$name></select>", function() {
  var fn, test, w;
  test = 1;
  fn = function(e) {
    return test = 10;
  };
  (w = this.w()).listen('click', fn).fire('click');
  this.is(test, 10);
  test = 1;
  w.drop('click', fn).fire('click');
  return this.is(test, 1);
});

new CTest('obj-CWidget-fire', "`fire type, [options]` - инициирует событие (в разработке)", "<select id=$name-sel></select>", function() {
  var sel, test;
  test = 1;
  (sel = this.w("sel")).listen('change', function(e) {
    return test = 10;
  }).fire("change");
  this.is(test, 10);
  sel.listen('mousemove', function(e) {
    return test = 20;
  }).fire("mousemove");
  this.is(test, 20);
  sel.listen('keypress', function(e) {
    return test = 30;
  }).fire("keypress");
  return this.is(test, 30);
});

new CTest('obj-CWidget-attach', "`attach name` - подключает элемент к форме.\nУ формы появляется @$название.\nЕсли название не совпадает со свойствами формы, то создаётся так же и такое свойство", function() {
  var form;
  form = $("<div id=obj-CWidget-attach-form ctype=form><div id=obj-CWidget-attach-form-listen></div><div id=obj-CWidget-attach-form-elem></div></div>");
  this.is(form.elem.name(), "elem");
  this.is(form.$elem.name(), "elem");
  this.is(form.$listen.name(), "listen");
  return this["instanceof"](form.listen, Function);
});

new CTest('obj-CWidget-detach', "`detach name` - отключает элемент от формы", function() {
  var lis, w;
  w = $("<div id=obj-CWidget-attach-form ctype=form><div id=obj-CWidget-attach-form-lis></div></div>");
  lis = w.byId("obj-CWidget-attach-form-lis");
  this.is(lis.parent(), w);
  this.is(w._elements[0], 'lis');
  this.is(w.lis, lis);
  w.detach('lis');
  this.is(lis._parent, null);
  this.is(lis.parent(), w);
  this.is(lis._parent, w);
  this.ok(!(lis in w));
  return this.is(w._elements.length, 0);
});

new CTest('obj-CWidget-getElements', "`getElements` - возвращает элементы формы", function() {
  var el, form;
  form = CRoot.wrap("<div id=obj-CWidget-getElements-form><div id=obj-CWidget-getElements-form-v></div></div>");
  el = form.getElements();
  this.is(el.length, 1);
  return this.is(el[0], "v");
});

CTest.category("методы поиска элементов");

new CTest('obj-CWidget-byId', "`byId id` - ищет в документе и возвращает виджет по id элемента", " <div id=$name></div> ", function() {
  this.is(CRoot.byId("not id"), null);
  return this.is(CRoot.byId("obj-CWidget-byId").id(), "obj-CWidget-byId");
});

new CTest('obj-CWidget-byName', "`byName name` - ищет в документе и возвращает виджет по его имени в форме. Аналогично @byId id-формы + тире + имя. Заодно проверяет parent", function() {
  var form;
  form = CRoot.wrap("<div id=obj-CWidget-byName-form><div id=obj-CWidget-byName-form-v></div></div>").appendTo(/body/);
  return this.is(form.byName("v"), form.byId("obj-CWidget-byName-form-v"));
});

new CTest('obj-CWidget-byTag', "`byTag tag` - ищет и возвращает первый попавшийся вложенный виджет по его тегу", function() {
  return this.is(CRoot.byTag("head").tag(), "HEAD");
});

new CTest('obj-CWidget-byClass', "`byTag tag` - ищет и возвращает первый попавшийся вложенный виджет по его классу", function() {
  return this.is(CRoot.byTag("head").tag(), "HEAD");
});

new CTest('obj-CWidget-byClassAll', "`byClassAll tag` - ищет и возвращает коллекцию вложенных виджетов по классу", function() {
  return this.is(CRoot.wrap("<div><b class=m1>1</b><b>0</b><b class=m1>2</b></div>").byClassAll("m1").length, 2);
});

new CTest('obj-CWidget-byTagAll', "`byTagAll tag` - ищет и возвращает коллекцию вложенных виджетов по тегу", function() {
  return this.is(CRoot.wrap("<div> x<b class=m1>1</b> <b>0</b> <b class=m1>2</b></div>").byTagAll("b").length, 3);
});

new CTest('obj-CWidget-first', "`first [selector]` - возвращает первый потомок, соответствующий селектору", function() {
  var w;
  this.is((w = CRoot.wrap("<div> <b>0</b> <b class=m1>2</b> <b class=m1>2</b></div>")).first("b[class]").html(), "2");
  return this.is(w.first().html(), "0");
});

new CTest('obj-CWidget-last', "`last [selector]` - возвращает последний потомок, соответствующий селектору", function() {
  var w;
  this.is((w = CRoot.wrap("<div> <b class=m1>2</b> <b class=m1>2</b> <b>3</b> </div>")).last("b[class]").html(), "2");
  return this.is(w.last().html(), "3");
});

new CTest('obj-CWidget-find', "`find selector` - возвращает все потомки, соответствующие селектору", function() {
  var w;
  this.is((w = CRoot.wrap("<div> <b class=m1>2</b> <b class=m1>2</b> <b>3</b> </div>")).find("b[class]").length, 2);
  return this.is(w.find(".m1").length, 2);
});

new CTest('obj-CWidget-byViewXY', "`byViewXY x, y` - возвращает виджет по его координатам на экране", "<div id=$name style=\"background: lightblue; width: 40px; height: 40px\">&nbsp;</div>", function() {
  var left, top, w, _ref;
  _ref = (w = this.w()).viewPos(), left = _ref.left, top = _ref.top;
  this.is(w, CRoot.byViewXY(left, top));
  this.is(w, CRoot.byViewXY(left + 20, top + 20));
  return this.is(w, CRoot.byViewXY(left + 39, top + 39));
});

new CTest('obj-CWidget-byXY', "`byXY x, y` - возвращает виджет по его координатам в документе", "<div id=$name style=\"background: lightblue; width: 40px; height: 40px\">&nbsp;</div>", function() {
  var left, top, w, _ref;
  _ref = (w = this.w()).pos(), left = _ref.left, top = _ref.top;
  this.is(w, CRoot.byXY(left, top));
  this.is(w, CRoot.byXY(left + 20, top + 20));
  return this.is(w, CRoot.byXY(left + 39, top + 39));
});

new CTest('obj-CWidget-byXYAll', "`byXYAll x, y` - возвращает все виджеты которые лежат в координатах документа x, y", "#%name-2, #%name-3 {width: 40px; height: 40px}\n#%name-2 {background: coral; margin-bottom: -20px; margin-left: 20px }\n#%name-3 {background: royalblue}", "<div id=$name>\n	<div id=$name-2></div>\n	<div id=$name-3></div>\n</div>", function() {
  var all, left, top, _ref;
  _ref = this.w().pos(), left = _ref.left, top = _ref.top;
  all = CRoot.byXYAll(left + 30, top + 30);
  this.is(all.length, 3);
  this.is(all.item(0), this.w(3));
  this.is(all.item(1), this.w(2));
  return this.is(all.item(2), this.w());
});

new CTest('obj-CWidget-byViewXYAll', "`byViewXYAll x, y` - возвращает все виджеты которые лежат в координатах экрана x, y", "#%name-2, #%name-3 {width: 40px; height: 40px}\n#%name-2 {background: coral; margin-bottom: -20px; margin-left: 20px }\n#%name-3 {background: royalblue}", "<div id=$name>\n	<div id=$name-2></div>\n	<div id=$name-3></div>\n</div>", function() {
  var all, left, top, _ref;
  _ref = this.w().viewPos(), left = _ref.left, top = _ref.top;
  all = CRoot.byViewXYAll(left + 30, top + 30);
  this.is(all.length, 3);
  this.is(all.item(0), this.w(3));
  this.is(all.item(1), this.w(2));
  return this.is(all.item(2), this.w());
});

new CTest('obj-CWidget-match', "`match selector` - возвращает true, если элемент соответствует селектору", function() {
  return this.is(CRoot.wrap("<b class=m1></b>").match("b.m1"), true);
});

CTest.category("методы коллекции");

new CTest('obj-CWidget-all', "`all` - возвращает массив класса Array, содержащий html-элементы, находящиеся в коллекции", function() {
  this["instanceof"](CRoot.all(), Array);
  this.is(CRoot.all()[0], CRoot.element);
  this["instanceof"](CRoot.find("b#m1"), CWidgets);
  return this["instanceof"](CRoot.find("b#m1").all(), Array);
});

new CTest('obj-CWidget-empty', "`empty` - определяет, что коллекция пуста. Возвращает true/false", function() {
  this.is(CRoot.empty(), false);
  return this.is(new CWidgets([]).empty(), true);
});

new CTest('obj-CWidget-length', "`length` - возвращает длину коллекции", function() {
  this.is(CRoot.length, 1);
  return this.is(new CWidgets([CRoot.element, CRoot.element]).length, 2);
});

new CTest('obj-CWidget-item', "`item index` - возвращает виджет из коллекции по индексу", function() {
  this.is(CRoot.item(0), CRoot);
  this.is(CRoot.item(1), void 0);
  return this.is(new CWidgets([CRoot.body().element, CRoot.element]).item(-1), CRoot);
});

new CTest('obj-CWidget-items', "`items` - возвращает виджеты из коллекции в виде массива", function() {
  this.is(CRoot.items()[0], CRoot);
  return this.is(new CWidgets([CRoot, CRoot]).items().length, 2);
});

new CTest('obj-CWidget-slice', "`slice [from], [to]` - делает вырезку из коллекции\n\n* from и to могут быть не только цифрами, но и селекторами: в этом случае ориентируются от совпадения селектора до совпадения селектора; и виджетами\n* если from взять в массив, то элемент исключается из коллекции\n* если to взять в массив, то элемент включается в коллекцию\n* второй элемент массива [from, 1] или [to, -1] может указывать с какого совпавшего с селектором элемента начинать вырезку. При этом не считается, что элемент взят в массив\n* третий элемент массива (1 или 0) указывает - включать или нет элемент: [from, 1, 1] - не включать, [to, 1, 1] - включать", function() {
  var w, x;
  this.is(CRoot.slice(0).length, 1);
  w = $("0 <i>1</i> 2 <b>3</b> 4 <i>5</i> 6 <i>7</i><em>8</em><u>9</u>");
  this.is(w.slice(5).length, 5);
  this.is(w.slice(0, 5).length, 5);
  this.is(w.slice(0, [5]).length, 6);
  this.is(w.slice([0], 5).length, 4);
  this.is(w.slice("b", 5).length, 2);
  this.is(w.slice(["b"], 5).length, 1);
  this.is(w.slice(["i", -2], "u").length, 4);
  this.is(w.slice(["i", -2, 1], "u").length, 3);
  this.is(w.slice(["i", -2], ["u"]).length, 5);
  this.is(w.slice(["i", -2], ["u", 0]).length, 4);
  this.is(w.slice(["i", -2], ["u", 0, 1]).length, 5);
  x = w.item(1);
  return this.is(w.slice(1, [x]).item(0), x);
});

new CTest('obj-CWidget-invoke', "`invoke name, args...` - выполняет метод name для каждого виджета в коллекции у котрого он есть. Возвращает себя", function() {
  return this.is(CRoot.invoke("all"), CRoot);
});

new CTest('obj-CWidget-map', "`map name, args...` - выполняет метод name для каждого виджета в коллекции у котрого он есть. Возвращает массив результатов", function() {
  this.is(CRoot.map("empty")[0], false);
  this.is(CRoot.map("not found method")[0], void 0);
  return this.is(CRoot.map("not found method").length, 1);
});

new CTest('obj-CWidget-result', "`result name, args...` - выполняет метод name для каждого виджета в коллекции у котрого он есть. Возвращает результат для первого виджета", function() {
  return this.is(CRoot.result("empty"), false);
});

new CTest('obj-CWidget-grep', "`grep name, args...` - выполняет метод name для каждого виджета в коллекции у котрого он есть. Возвращает новую коллекцию с виджетами, методы к-х вернули положительный результат", function() {
  this.is(CRoot.grep("empty").length, 0);
  return this.is(CRoot.grep("all"), CRoot);
});

new CTest('obj-CWidget-exists', "`exists name` - возвращает новую коллекцию с виджетами у которых есть метод name", function() {
  return this.is(CRoot.exists("empty"), CRoot);
});

new CTest('obj-CWidget-filter', "`filter query` - возвращает новую коллекцию с элементами соответствующими query", function() {
  this.is(CRoot.filter("html"), CRoot);
  return this.ok(CRoot.filter("b").empty());
});

CTest.category("методы клонирования элемента");

new CTest('obj-CWidget-clone', "`clone [id], [parent], [cls]` - возвращает клонированный элемент, с новым id, парентом и классом виджета, если последние указаны", function() {
  var w;
  w = CRoot.wrap("<div id=exid ctype=img><b id=exid-b></b></div>").clone("exid2", CRoot, CInputWidget);
  this.is(w.id(), 'exid2');
  this.is(w.child(0).id(), 'exid2-b');
  this.is(w.parent(), CRoot);
  return this["instanceof"](w, CInputWidget);
});

new CTest('obj-CWidget-clonehtml', "`clonehtml [id], [parent], [cls]` - возвращает html клона элемента, с новым id, парентом и классом виджета, если последние указаны", function() {
  var html;
  html = CRoot.wrap("<div id=exid><b id=exid-b></b></div>").clonehtml("exid2", CRoot.wrap("<div id=exid3></div>"), CInputWidget);
  return this.is(html, '<div id="exid2" cparent=exid3 ctype=CInputWidget><b id="exid2-b"></b></div>');
});

CTest.category("методы атрибутов и содержимого");

new CTest('obj-CWidget-id', "`id [id]` - возвращает или устанавливает id элемента", function() {
  var w;
  this.is((w = CRoot.wrap('<div id=exid></div>')).id(), 'exid');
  return this.is(w.id('exid2').id(), 'exid2');
});

new CTest('obj-CWidget-name', "`name [name]` - возвращает или устанавливает имя элемента формы. Именем элемента формы считается последнее слово в конце идентификатора", function() {
  var w;
  this.is((w = CRoot.wrap('<div id=exid-name></div>')).name(), 'name');
  return this.is(w.name('ps').name(), 'ps');
});

new CTest('obj-CWidget-number', "`number [number]` - возвращает или устанавливает номер в конце идентификатора элемента", function() {
  var w;
  this.is((w = CRoot.wrap('<div id=exid3></div>')).number(), '3');
  return this.is(w.number(2).number(), "2");
});

new CTest('obj-CWidget-tag', "`tag [tag]` - возвращает или устанавливает тег элемента", function() {
  var w;
  this.is((w = CRoot.wrap('<div></div>')).tag(), 'DIV');
  return this.is(w.tag("b").tag(), "B");
});

new CTest('obj-CWidget-val', "`val [val]` - возвращает или устанавливает атрибут value элемента", function() {
  var w;
  this.is((w = CRoot.wrap('<input value="10" />')).val(), '10');
  return this.is(w.val("b").val(), "b");
});

new CTest('obj-CWidget-val$f', "`val$f` - возвращает атрибут value элемента преобразованный в число с плавающей точкой", function() {
  this.is(CRoot.wrap('<div>10.5</div>').val$f(), 10.5);
  return this.is(CRoot.wrap('<input value="10.5" />').val$f(), 10.5);
});

new CTest('obj-CWidget-val$i', "`val$i [radix]` - возвращает атрибут value элемента преобразованный в целое число. radix - база числа: 2, 3, 8, 10, 16 и т.п.", function() {
  return this.is(CRoot.wrap('<input value="10.5" />').val$i(), 10);
});

new CTest('obj-CWidget-inc', "`inc [increment]` - увеличивает атрибут value элемента на increment или 1", function() {
  return this.is(CRoot.wrap('<input value="10" />').inc(2).val$i(), 12);
});

new CTest('obj-CWidget-dec', "`inc [increment]` - уменьшает атрибут value элемента на increment или 1", function() {
  return this.is(CRoot.wrap('<input value="10" />').dec().val$i(), 9);
});

new CTest('obj-CWidget-text', "`text [text]` - возвращает или устанавливает текст внутри элемента", function() {
  this.is(CRoot.wrap('<div><b>2</b></div>').text(), "2");
  return this.is(CRoot.wrap('<div>2</div>').text(3).text(), "3");
});

new CTest('obj-CWidget-html', "`html [html]` - возвращает или устанавливает html внутри элемента", function() {
  return this.is($('<div>2</div>').html("<b>3</b>").html(), "<b>3</b>");
});

new CTest('obj-CWidget-htmlscript', "`htmlscript [html]` - устанавливает html внутри элемента и выполняет все теги <script>, без тега type или с type=text/javascript", function() {
  return this.is($('<div>2</div>').html("<b>3</b>").html(), "<b>3</b>");
});

new CTest('obj-CWidget-content', "`content [content]` - возвращает или устанавливает содержимое элемента - коллекцию нод. При установке можно использовать любой аргумент, который может быть преобразован в ноду или коллекцию", function() {
  return this.is(CRoot.wrap('<div>2</div>').content("<b>3</b>").content().outer(), "<b>3</b>");
});

new CTest('obj-CWidget-normalize', "`normalize` - нормализует текстовые ноды, сливая их, если это возможно, вместе, а так же удаляя пустые", function() {
  var t1, t2, w;
  t1 = document.createTextNode("1");
  t2 = document.createTextNode("2");
  w = CRoot.wrap("<div></div>").append([t1, t2]);
  this.is(w.down().length, 2);
  return this.is(w.normalize().down().length, 1);
});

new CTest('obj-CWidget-update', "`update` - определяет, как будет происходить апдейт виджета. Используется загрузчиком", function() {
  return this.is($("<div>2</div>").update("3").html(), "3");
});

new CTest('obj-CWidget-outer', "`outer [content]` - возвращает outerHTML элемента. Если указан content, то заменяет элемент виджета на него", function() {
  var w, x;
  this.is($("<div>2</div>").outer("<b>3</b>").outer(), "<b>3</b>");
  this.is($(" <i></i> <u></u>").outer(), " <i></i> <u></u>");
  this.is((w = $("<div>2</div>")).outer(x = $("<b>3</b>")).outer(), "<b>3</b>");
  return this.is(x.element, null);
});

new CTest('obj-CWidget-before', "`before content, [timeout], [listen]` - вставляет content перед виджетом", function() {
  this.is($("<i><b>1</b><b>2</b></i>").child(1).before("3").up().outer(), "<i><b>1</b>3<b>2</b></i>");
  this.is((new CWidgets([$("<i><b>1</b><b>2</b></i>").child(1).element])).before("3").up().outer(), "<i><b>1</b>3<b>2</b></i>");
  this.is((new CWidgets([$("<i><b>1</b><b>2</b></i>").child(1).element])).before(new CWidgets([$("3").element])).up().outer(), "<i><b>1</b>3<b>2</b></i>");
  return this.is($("<i><b>1</b><b>2</b></i>").child(1).before(new CWidgets([$("3").element])).up().outer(), "<i><b>1</b>3<b>2</b></i>");
});

new CTest('obj-CWidget-insertBefore', "`insertBefore content, [timeout], [listen]` - вставляет виджет перед content-ом", function() {
  var w;
  $("<i>2</i>").insertBefore((w = $("<i>1<u>3</u></i>")).down(1));
  return this.is(w.outer(), "<i>1<i>2</i><u>3</u></i>");
});

new CTest('obj-CWidget-after', "`after content, [timeout], [listen]` - вставляет content после виджета\n\n#append", function() {
  return this.is($("<i><b>1</b><b>2</b></i>").child(-1).after("3").up().outer(), "<i><b>1</b><b>2</b>3</i>");
});

new CTest('obj-CWidget-insertAfter', "`insertAfter content, [timeout], [listen]` - вставляет виджет после content-а\n\n#append", function() {
  var w;
  $("<i>2</i>").insertAfter((w = $("<i>1<u>3</u></i>")).down(0));
  return this.is(w.outer(), "<i>1<i>2</i><u>3</u></i>");
});

new CTest('obj-CWidget-append', "`append content, [timeout], [listen]` - вставляет content в конец виджета\n\n* timeout - время за которое будет осуществляться перемещение\n* listen - функция, которая сработает после перемещения. Если timeout не указан, то он станет 'norm'\n", "#%name-c1, #%name-c2, #%name-c3 { padding: 4px; background: lavender; border: solid 1px orange }\n#%name-c2, #%name-c3 {position: absolute; margin: -20px 0 0 400px }\n#%name-c3 { margin: -20px 0 0 800px !important }\n#%name-1, #%name-2 { background: LightSlateGray }", "<div id=%name-c1>\n	\n</div>\n\n<div id=%name-c2>\n	старт путешественника 1\n	<div id=%name-1>путешественник 1</div>\n</div>\n\n<div id=%name-c3>\n	<div id=%name-2>путешественник 2</div>\n	старт путешественника 2\n</div>\n\n<a id=%name-b1 href=\"#\">Обратно</a>\n\n", function() {
  var c1, c2, c3, i1, i2, self;
  this.count(2);
  this.is($("<i>1</i>").append("3").outer(), "<i>13</i>");
  self = this;
  (c1 = this.w("c1")).append((i1 = this.w("1")).union(i2 = this.w("2")), "fast", function() {
    return self.is(i1.up().name(), "c1");
  });
  c2 = this.w("c2");
  c3 = this.w("c3");
  return this.w("b1").on("click", function() {
    if (i1.up().name() === 'c1') {
      c2.append(i1, "fast");
      c3.append(i2, "fast");
    } else {
      c1.append(i1.union(i2), "fast");
    }
    return false;
  });
});

new CTest('obj-CWidget-appendTo', "`appendTo content, [timeout], [listen]` - вставляет виджет в конец content-а\n\nСм. #append", function() {
  var w;
  $("<i>1</i>").appendTo(w = $("<em>2</em>"));
  return this.is(w.html(), "2<i>1</i>");
});

new CTest('obj-CWidget-prepend', "`prepend content, [timeout], [listen]` - вставляет content в начало виджета", function() {
  return this.is($("<i>1</i>").prepend("3").outer(), "<i>31</i>");
});

new CTest('obj-CWidget-prependTo', "`prependTo content, [timeout], [listen]` - вставляет виджет в начало content-а", function() {
  var w;
  $("<i>1</i>").prependTo(w = $("<em>2</em>"));
  return this.is(w.html(), "<i>1</i>2");
});

new CTest('obj-CWidget-swap', "`swap content, [timeout], [listen]` - меняет элементы в DOM местами", function() {
  var w, x;
  w = $("<i><b>1</b><u>2</u></i>");
  w.child(0).swap(w.child(1));
  this.is(w.outer(), "<i><u>2</u><b>1</b></i>");
  w = $("<i><b>1</b><u>2</u></i>");
  w.child(1).swap(w.child(0));
  this.is(w.outer(), "<i><u>2</u><b>1</b></i>");
  w = $("<i><b>1</b><u>2</u>3</i>");
  w.child(0).swap(w.child(1));
  this.is(w.outer(), "<i><u>2</u><b>1</b>3</i>");
  w = $("<i><b>1</b><u>2</u>3</i>");
  w.child(1).swap(w.child(0));
  this.is(w.outer(), "<i><u>2</u><b>1</b>3</i>");
  w = $("<i><b>1</b><u>2</u><em>3</em></i>");
  w.child(2).swap(w.child(0));
  this.is(w.outer(), "<i><em>3</em><u>2</u><b>1</b></i>");
  w = $("<i>1</i>");
  x = w.down(0).swap("<u>2</u>");
  this.is(w.outer(), "<i><u>2</u></i>");
  this.is(x.up(), null);
  this.is((w = $("1")).swap("2"), w);
  w = $("<i><b>1<u>2<em>3</em></u></b></i>");
  w.swap(x = w.child(0).child(0));
  this.is(x.outer(), "<u><b>1<i>2<em>3</em></i></b></u>");
  w = $("<i><u>1</u>2</i>");
  (x = w.child(0)).swap(w);
  this.is(x.outer(), "<u><i>1</i>2</u>");
  w = $("<i><u>1</u>2</i>");
  w.swap(x = w.child(0));
  this.is(x.outer(), "<u><i>1</i>2</u>");
  w = new CWidgets([$("<i><u>1</u>2</i>").element]);
  w.swap(x = w.child(0));
  this.is(x.outer(), "<u><i>1</i>2</u>");
  w = new CWidgets([$("<i><u>1</u>2</i>").element]);
  w.swap(x = w.child());
  return this.is(x.outer(), "<u><i>1</i>2</u>");
});

new CTest('obj-CWidget-wrapIn', "`wrapIn content` - оборачивает виджет в content. С коллекцией желательно задавать текст, т.к. content не клонируется\n\nВозвращает content преобразованный в виджет", function() {
  var w;
  w = $("<i>1</i>").wrapIn("<p><em>2</em><b>3</b></p>");
  this.is(w.upAll().item(-1).outer(), "<p><em><i>1</i></em><b>3</b></p>");
  w = $(["<i>1</i>", "2", "<i>3</i>"]).wrapIn("<p></p>");
  return this.is(w.outer(), "<p><i>1</i></p><p>2</p><p><i>3</i></p>");
});

new CTest('obj-CWidget-wrapInAll', "`wrapInAll content` - оборачивает виджет или коллекцию виджетов в content\n\nВозвращает content преобразованный в виджет", function() {
  var w;
  $(["<i>1</i>", "2", "<i>3</i>"]).wrapInAll(w = $("<p></p>"));
  return this.is(w.outer(), "<p><i>1</i>2<i>3</i></p>");
});

new CTest('obj-CWidget-floor', "`floor` - возвращает элемент расположенный под элементом. Используется в старой функции нахождения координат элемента\n\nСм. #floorAll, #domfloor, #up", "#$name, #$name-w { width: 100px; height: 100px; background: green }\n#$name {position: absolute; z-index: 1000; background: red; margin-left: 10px; margin-top: 10px; }", "<div id=$name></div>\n<div id=$name-w></div>", function() {});

new CTest('obj-CWidget-up', "`up` - возвращает вышестоящую ноду в дереве", function() {
  var w;
  this.is((w = $("<i>2</i>").down(0)).outer(), "2");
  return this.is(w.up().outer(), "<i>2</i>");
});

new CTest('obj-CWidget-upper', "`upper` - возвращает вышестоящий элемент в дереве", function() {
  var f, w;
  f = document.createDocumentFragment();
  f.appendChild((w = $("<i>2</i>")).element);
  this.is(w.upper(), null);
  this.is((w = w.down(0)).outer(), "2");
  return this.is(w.upper().outer(), "<i>2</i>");
});

new CTest('obj-CWidget-next', "`next` - возвращает соседний следующий элемент", function() {
  return this.is($("<i><b>1</b>_<b>2</b></i>").child(0).next().html(), "2");
});

new CTest('obj-CWidget-prev', "`prev` - возвращает соседний предыдущий элемент", function() {
  return this.is($("<i><b>1</b><b>2</b></i>").child(1).prev().html(), "1");
});

new CTest('obj-CWidget-nextnode', "`nextnode` - возвращает соседнюю следующую ноду", function() {
  return this.is($("<i><b>1</b>2</i>").child(0).nextnode().text(), "2");
});

new CTest('obj-CWidget-prevnode', "`prevnode` - возвращает соседнюю предыдущую ноду", function() {
  return this.is($("<i>1<b>2</b></i>").child(0).prevnode().text(), "1");
});

new CTest('obj-CWidget-upAll', "`upAll` - возвращает все вышестоящие ноды в дереве", function() {
  var f, w;
  f = document.createDocumentFragment();
  f.appendChild((w = $("<i><b><em>1</em></b></i>")).element);
  return this.is(w.down(0).down(0).down(0).upAll().length, 4);
});

new CTest('obj-CWidget-upperAll', "`upperAll` - возвращает все вышестоящие элементы в дереве", function() {
  var f, w;
  f = document.createDocumentFragment();
  f.appendChild((w = $("<i><b><em>1</em></b></i>")).element);
  return this.is(w.down(0).down(0).down(0).upperAll().length, 3);
});

new CTest('obj-CWidget-nextAll', "`nextAll` - возвращает все соседние элементы", function() {
  return this.is($("<i><b>1</b><b>2</b>_<x>3</x></i>").child(0).nextAll().outer(), "<b>2</b><x>3</x>");
});

new CTest('obj-CWidget-prevAll', "`prevAll` - возвращает все соседние предыдущие элементы", function() {
  return this.is($("<i> <b>1</b> <i>2</i> <b>3</b> </i>").child(-1).prevAll().outer(), "<b>1</b><i>2</i>");
});

new CTest('obj-CWidget-nextnodeAll', "`nextnodeAll` - возвращает соседние следующие ноды", function() {
  return this.is($("<i><b>1</b>2<em>3</em></i>").child(0).nextnodeAll().outer(), "2<em>3</em>");
});

new CTest('obj-CWidget-prevnodeAll', "`prevnodeAll` - возвращает соседние предыдущие ноды", function() {
  return this.is($("<i><em>0</em>1<b>2</b></i>").child(-1).prevnodeAll().outer(), "<em>0</em>1");
});

new CTest('obj-CWidget-child', "`child [index]` - возвращает коллекцию дочерних элементов. С index - возвращает дочерний элемент с таким индексом", function() {
  this.is($("<i><em>0</em>1<b>2</b>3</i>").child(-1).outer(), "<b>2</b>");
  return this.is($("<i><em>0</em>1<b>2</b>3</i>").child().outer(), "<em>0</em><b>2</b>");
});

new CTest('obj-CWidget-down', "`down [index]` - возвращает коллекцию дочерних нод. С index - возвращает дочернюю ноду с таким индексом", function() {
  this.is($("<i><em>0</em>1<b>2</b>3</i>").down(-1).outer(), "3");
  return this.is($("<i><em>0</em>1<b>2</b>3</i>").down().outer(), "<em>0</em>1<b>2</b>3");
});

new CTest('obj-CWidget-remove', "`remove` - удаляет виджет. Как из дерева DOM, так и удаляет сам элемент в виджете\n\nСм. #free", function() {
  var w, x;
  w = $("<i><em>0</em>1<b>2</b>3</i>");
  x = w.child(-1);
  x.remove();
  this.is(x.element, null);
  return this.is(w.outer(), "<i><em>0</em>13</i>");
});

new CTest('obj-CWidget-free', "`free` - удаляет элемент из дерева DOM. Элемент остаётся и его можно добавить обратно в DOM\n\nСм. #remove", function() {
  var w, x;
  w = $("<i><em>0</em>1<b>2</b>3</i>");
  x = w.child(-1);
  x.free();
  this.is(w.outer(), "<i><em>0</em>13</i>");
  return this.is(w.append(x).outer(), "<i><em>0</em>13<b>2</b></i>");
});

new CTest('obj-CWidget-focus', "`focus` - устанавливает фокус на элемент\n\nСм. #hasFocus", "<input id=$name>", function() {
  var w;
  w = this.w().focus();
  return this.ok(w.hasFocus());
});

new CTest('obj-CWidget-hasFocus', "`hasFocus` - проверяет - в фокусе ли элемент\n\nСм. #hasFocus", "<input id=$name>", function() {
  this.is(this.w().hasFocus(), false);
  this.is(this.w().focus(), this.w());
  return this.is(this.w().hasFocus(), true);
});

new CTest('obj-CWidget-contains', "`contains [content]` - возвращает дочерние ноды или устанавливает контент как дочерние ноды\n\nСм. #down", function() {
  var w;
  this.is((w = $("<div>1<i>2</i></div>")).content().length, 2);
  w.content("<u>3</u>4");
  return this.is(w.content().outer(), "<u>3</u>4");
});

CTest.category("Манипулирование таблицей");

new CTest('obj-CWidget-tab', "`tab [i, [j, [, content]]]`\n\n* `tab` - возвращает размерность таблицы, например, [5,5]\n* `tab i` - возвращает строку new CWidgets [td11, td12...]\n* `tab null, j` - возвращает столбец new CWidgets [td11, td21...]\n* `tab i, j` - возвращает элемент ячейки\n* `tab i, j, content` - устанавливает content в ячейку\n* `tab i, j, {row: row, col: col}` - задаёт область, возвращаемую в виде матрицы. Элементы матрицы - виджеты\n* `tab i, j, {}` - до конца таблицы\n* `tab {}` - всю таблицу\n* `tab [i], [j], {cells: матрица}` - устанавливает контент как ячейку или ячейки, если задан массив или матрица\n* `tab {row: row, col: col}` - создаёт таблицу заданной размерности и возвращает её элементы в виде матрицы\n* `tab i, [content11, content12...]` - устанавливает строку таблицы\n* `tab null, j, [content11, content21...]` - устанавливает столбец\n* `tab [[content11, content12...]...]` - устанавливает таблицу\n* `tab i, j, [[content11, content12...]...]` - устанавливает ячейки с определённого i, j\n\n", "#$name-div div { border: solid 1px Cornsilk }\n#$name-div span { border: solid 1px lavender; background: MistyRose; *zoom: 1; display: inline; display: -moz-inline-stack; display: inline-block; }", "<table id=$name border=1></table>\n\n<div id=$name-div></div>", function() {
  var col, matrix, row, w, _ref, _ref1;
  _ref = (w = this.w()).tab(), row = _ref[0], col = _ref[1];
  this.is(row, 0);
  this.is(col, 0);
  w.tab(1, 1, 10);
  this.is(w.byTagAll('tr').length, 2);
  this.is(w.byTagAll('td').length, 2);
  _ref1 = w.tab(), row = _ref1[0], col = _ref1[1];
  this.is(row, 2);
  this.is(col, 2);
  this.is(w.tab(0, 1), null);
  this.is(w.tab$(1, 1), "10");
  w.tab(0, 1, [[20, 30]]);
  this.is(w.tab(0, 1).html(), '20');
  this.is(w.tab(0, 2).text(), '30');
  w.tab(null, 1, [50, 60, 70]);
  this.is(w.tab$i(0, 1), 50);
  this.is(w.tab$i(1, 1), 60);
  this.is(w.tab$i(2, 1), 70);
  w.tab(null, 1, [100]);
  this.is(w.tab$(0, 1), "100");
  this.is(w.tab$(1, 1), "");
  this.is(w.tab$(2, 1), "");
  w = this.w("div");
  w.tab(1, 1, [[10, 20, 30]]);
  this.is(w.tab$(1, 1), "10");
  this["instanceof"](w.tab(1), CWidgets);
  w.html("");
  matrix = w.tab({
    row: 2,
    col: 6
  });
  this["instanceof"](matrix, Array);
  this.is(matrix.length, 2);
  this["instanceof"](matrix[0], Array);
  return this.is(matrix[0][0].html(1).html(), "1");
});

new CTest('obj-CWidget-tab$', "`tab$ [i, [j, [, content]]]` - полностью аналогично #tab, только возвращает не виджеты, а innerHTML\n\nСм. #html", function() {
  return this.is($('<div></div>').tab$(0, 0), "");
});

new CTest('obj-CWidget-tab$i', "`tab$ [i, [j, [, content]]]` - полностью аналогично #tab, только возвращает не виджеты, а #val$i\n\nСм. #val, #val$f", function() {
  return this.is($('<div></div>').tab$i(0, 0), 0);
});

new CTest('obj-CWidget-tab$f', "`tab$ [i, [j, [, content]]]` - полностью аналогично #tab, только возвращает не виджеты, а #val$f\n\nСм. #val, #val$i", function() {
  return this.is($('<div></div>').tab$f(0, 0), 0);
});

new CTest('obj-CWidget-rawstyle', "`rawstyle [selector], [val], [before]` - работает с таблицами стилей. После первого же вызова - кеширует их. Кеш нужно сбрасывать вручную через `rawstyle 0`\n\n1. `rawstyle` - возвращает все правила, влияющие на элемент. Правила имеют тип CSSStyleRule\n1. `rawstyle 0` - сбрасывает кэш. Необходим, если таблицы стилей были изменены не через rawstyle или style\n1. `rawstyle selector` - возвращает правила с указанным селектором. Селектор может быть как строкой, так и RegExp - в этом случае возвращает все подходящие под регулярку правила\n1. `rawstyle rule` - удаляет правило. rule типа CSSStyleRule\n1. `rawstyle selector, {name1: val1...}|text, [beforeRule|styleSheet]` - добавляет правило перед указанным правилом или в конец указанной страницы стилей. Если же ничего не указано - то в конец специальной страницы, создающейся при первом присваивании\n\nПрим. Если необходимо создать страницу стилей, то воспользуйтесь @wrap('<style></style>').appendTo @head(); stylesheet$ = (s=@document().styleSheets)[s.length-1]\n\nСм. #style, #css", ".rawstyle-example { background: red }\n#$name {background: blue}", "<div id=$name class=rawstyle-example>&nbsp;</div>", function() {
  var styles, w;
  w = this.w();
  styles = w.rawstyle();
  this.is(styles.length, 2);
  this.is(styles[0].style.backgroundColor, "red");
  this.is(styles[1].style.backgroundColor, "blue");
  this.is(styles[0].selectorText, '.rawstyle-example');
  this.is(styles[1].selectorText.toLowerCase(), '#' + this.name.toLowerCase());
  styles = w.rawstyle('.rawstyle-example');
  this.is(styles[0].selectorText, '.rawstyle-example');
  w.rawstyle(styles[0]);
  return this.is(w.rawstyle().length, 1);
});

new CTest('obj-CWidget-style', "`style [selector], [name], [val]` - пропускает стили через css-эмулятор, чего не делает rawstyle\n\n1. `style` - возвращает массив селекторов правил стилей в которых участвует элемент\n2. `style selector, name` - возвращает стиль из первого правила с указанным селектором\n3. `style selector, name, val, [important]` - устанавливает стиль первого правила с таким селектором или создаёт правило\n3. `style selector, null` - удаляет все правила с таким селектором\n1. `style {name1: val1...}, [important]` - заменяет стили на указанные в первом правиле с селектором #id элемента или создаёт его\n2. `style selector, {name1: val1...}` - заменяет стили в первом правиле с указанным селектором или создаёт его\n2. `style selector, [name1, name2...]` - возвращает стили из первого правила с указанным селектором\n1. `style name` - возвращает стиль из первого правила #id\n1. `style [name1, name2...]` - возвращает стили из первого правила #id с указанным селектором\n\nНовые правила создаются в специальной таблице стилей\n\nТакже см.: [rawstyle], [css]", ".style-example { background: red }\n#$name {background: blue}", "<div id=$name class=style-example>&nbsp;</div>", function() {
  var color, styles, w, _ref, _ref1;
  w = this.w();
  styles = w.style();
  this.is(styles.length, 2);
  this.is(styles[0], '.style-example');
  this.is(styles[1].toLowerCase(), '#' + this.name.toLowerCase());
  this.is(w.style('.style-example', 'background-color'), 'red');
  w.style('.style-example', 'background-color', 'green');
  this.is(w.style('.style-example', 'background-color'), 'green');
  w.style('.style-example', {
    'background-color': 'royalblue',
    color: 'green'
  });
  this.is(w.style('.style-example', 'color'), 'green');
  color = ['royalblue', 'rgb(65, 105, 225)', '#4169e1', 'rgba(65, 105, 225, 1)'];
  this.ok((_ref = w.style('.style-example', ['background-color'])['background-color'], __indexOf.call(color, _ref) >= 0));
  w.style('.style-example', null);
  this.is(w.style().length, 1);
  this.is(w.style('.style-example', 'background'), null);
  w.style('.style-example', {
    background: 'royalblue',
    color: 'green'
  });
  this.ok((_ref1 = w.style('.style-example', ['background-color'])['background-color'], __indexOf.call(color, _ref1) >= 0));
  return this.is(w.style().length, 2);
});

new CTest('obj-CWidget-rule', "`rule selector, [styles]` - возвращает объект со стилями для правил с таким селектором или заменяет их указанными стилями\n\nЕсли требуется вернуть стили, а правила с таким селектором не существует, то возвращается {}\n\n!important не возвращается\n\nСм. #rawstyle, #style", ".rule-example { background: red /* hi! */ !important; float: left }", "<div id=$name></div>", function() {
  var rule;
  rule = this.w().rule('.rule-example');
  this.is(rule.background, 'red');
  this.is(rule.float, 'left');
  this.ok(!('color' in rule));
  this.w().rule('.rule-example', {
    color: 'red'
  });
  rule = this.w().rule('.rule-example');
  this.is(rule.background, void 0);
  this.is(rule.float, void 0);
  return this.is(rule.color, 'red');
});

new CTest('obj-CWidget-pseudo', "`pseudo pseudoElementOrClass` - возвращает объект для псевдокласса или псевдоэлемента, который можно использовать для работы с [css]\n\nПримечание. Установка происходит через таблицу стилей\n\nТакже см.: #style, #css, #hasCss, #toggle", "<a href=\"#\" id=$name>1</a>", function() {
  var p, w;
  p = (w = this.w()).pseudo(':hover');
  p.css('background', 'royalblue');
  this.is(w.rgba('background-color') + "", 'rgba(0, 0, 0, 0)');
  return this.is(p.rgba('background-color') + "", 'rgba(65, 105, 225, 1)');
});

new CTest('obj-CWidget-hasCss', "`hasCss style, [val]` - тестирует браузер на наличие указанного стиля. Если указан val, то может ли стиль иметь такое свойство\n\nТакже см.: #style, #css, #toggle", function() {
  this.ok(CRoot.hasCss('z-index'));
  this.ok(CRoot.hasCss('z-index', 1));
  this.ok(!CRoot.hasCss('z-index', "0px"));
  return this.ok(CRoot.hasCss('background', 'linear-gradient(rgba(5,5,6,0.5), rgba(5,5,7,0.5))'));
});

new CTest('obj-CWidget-css', "`css style, [val]` - возвращает или устанавливает стили элемента\n\n1. Если style - объект, то устанавливает пары ключ-значение, как селектор-значение\n2. Если style - массив, то возвращает ассоциативный массив со стилями элемента\n3. Числовым значениям прибавляется \"px\", тем стилям где это нужно (width, font-size и т.д.)\n4. Стили с бета-префиксами, вроде -webkit-transform, -moz-transform, преобразовываются в стили без префикса: transform\n5. У метода css есть свойства:\n5.1 with_css_prefix - ассоциативный массив, где ключём выступает \n5.2 toCssCase - преобразует ключ из вида использующегося в JavaScript в вид css\n5.3 css_not_px - содержит ключи вида JavaScript, значения которых не нужно переводить в пикселы\n5.4 css_px: css_px - содержит ключи вида JavaScript, значения которых нужно переводить в пикселы\n5.5 css_set_fn - содержит ключи вида JavaScript и функции установки значения стиля\n5.6 css_get_fn - содержит ключи вида JavaScript и функции возврата значения стиля\n\nТакже см.: #style, #hasCss", "<div id=$name></div>", function() {
  var w;
  w = this.w();
  this.is(w.css('float', 'left'), w);
  this.is(w.css('float'), 'left');
  w = $('<div></div>');
  this.is(w.css('float', 'left'), w);
  this.is(w.css('float'), 'left');
  w = w.pseudo("");
  this.is(w.css('float', 'left'), w);
  return this.is(w.css('float'), 'left');
});

new CTest('obj-CWidget-px', " \n`px style` - возвращает значение стиля в пикселах\n\nТакже см.: #style, #hasCss, #css, #em, #rgba", "\n<div style=\"padding:10px; border: solid 1px gray\">\n<div id=$name class=test-square></div>\n</div>\n<div id=$name-log></div>\n", function() {
  var log, w;
  w = this.w();
  log = this.w("log");
  log.append("viewWidth=" + w.viewWidth() + '<br>');
  log.append("viewHeight=" + w.viewHeight() + '<br>');
  log.append("real.px=" + w.width() + '<br>');
  log.append("px=" + w.px('width') + "=" + w.px(150) + '<br>');
  log.append("vw=" + w.vw('width') + "=" + w.px('150vw') + '<br>');
  log.append("vh=" + w.vh('width') + "=" + w.px('150vh') + '<br>');
  log.append("vmin=" + w.vmin('width') + "=" + w.px('150vmin') + '<br>');
  log.append("pw=" + w.ph('width') + "=" + w.px('150pw') + '<br>');
  log.append("ph=" + w.ph('width') + "=" + w.px('150ph') + '<br>');
  log.append("em=" + w.em('width') + "=" + w.px('150em') + '<br>');
  log.append("rem=" + w.rem('width') + "=" + w.px('150rem') + '<br>');
  log.append("ex=" + w.ex('width') + "=" + w.px('150ex') + '<br>');
  log.append("pt=" + w.pt('width') + "=" + w.px('150pt') + '<br>');
  log.append("mm=" + w.mm('width') + "=" + w.px('150mm') + '<br>');
  log.append("cm=" + w.cm('width') + "=" + w.px('150cm') + '<br>');
  log.append("pc=" + w.pc('width') + "=" + w.px('150pc') + '<br>');
  log.append("in=" + w["in"]('width') + "=" + w.px('150in') + '<br>');
  return this.is(w.px('width'), 150);
});

new CTest('obj-CWidget-rgba', "`rgba style` - возвращает объект CColor, который затем можно преобразовать в любой из представления цвета\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is(CRoot.rgba('#4169E1').name(), 'royalblue');
});

new CTest('obj-CWidget-vw', "`vw style` - возвращает значение стиля в процентах от ширины окна\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.vw(150) + 'vw'), 150);
});

new CTest('obj-CWidget-vh', "`vh style` - возвращает значение стиля в процентах от высоты окна\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.vh(150) + 'vh'), 150);
});

new CTest('obj-CWidget-vmin', "`vmin style` - возвращает значение стиля в процентах от высоты или, если ширина меньше высоты, ширины окна\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.vmin(150) + 'vmin'), 150);
});

new CTest('obj-CWidget-pw', "`pw style` - возвращает значение стиля в процентах от ширины элемента\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.pw(150) + 'pw'), 150);
});

new CTest('obj-CWidget-ph', "`ph style` - возвращает значение стиля в процентах от высоты элемента\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.ph(150) + 'ph'), 150);
});

new CTest('obj-CWidget-em', "`em style` - возвращает значение стиля в размерах шрифта элемента\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.em(150) + 'em'), 150);
});

new CTest('obj-CWidget-rem', "`rem style` - возвращает значение стиля в размерах шрифта элемента HTML\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.rem(150) + 'rem'), 150);
});

new CTest('obj-CWidget-ex', "`rem style` - возвращает значение стиля в размерах шрифта элемента HTML\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  this.is$f(CRoot.px(CRoot.ex(150) + 'ex'), 150);
  return this.ok(CRoot.px('150ex') < CRoot.px('150em'));
});

new CTest('obj-CWidget-pt', "`pt style` - возвращает значение стиля в пунктах\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.pt(150) + 'pt'), 150);
});

new CTest('obj-CWidget-cm', "`cm style` - возвращает значение стиля в сантиметрах\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.cm(150) + 'cm'), 150);
});

new CTest('obj-CWidget-mm', "`mm style` - возвращает значение стиля в миллиметрах\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.mm(150) + 'mm'), 150);
});

new CTest('obj-CWidget-in', "`in style` - возвращает значение стиля в дюймах\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot["in"](150) + 'in'), 150);
});

new CTest('obj-CWidget-pc', "`pc style` - возвращает значение стиля в пиках\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  return this.is$f(CRoot.px(CRoot.pc(150) + 'pc'), 150);
});

new CTest('obj-CWidget-toggle', "* `toggle name, styles...` - переключает стиль name на следующий из styles\n* `toggle` - переключает стиль _display_ между 'none' и ''\n* `toggle name, style` - переключает стиль name между его значением и ''\n\nТакже см.: #style, #hasCss, #css, #px", function() {
  var w;
  w = $('<div></div>').toggle();
  this.is('none', w.element.style['display']);
  w.css('color', 'red');
  w.toggle('color', ['blue', 'green', 'red']);
  return this.is('blue', w.element.style['color']);
});

CTest.category("методы атрибутов и свойств");

new CTest('obj-CWidget-attr', "* `attr name, [val]` - устанавливает, возвращает или удаляет атрибут\n* `attr [name1, ...]` - возвращает объект с значениями указанных атрибутов\n* `attr name, null` - удаляет атрибут\n* `attr {name1: val1 ...}` - множественное присваивание/удаление\n\n'Примечание' - если атрибута нет, то возвращается null\n\nСм. #prop, #toggleAttr, #css, #addClass", "<div id=\"$name\"></div>", function() {
  var w;
  w = this.w();
  this.is(null, w.attr("attribute"));
  this.ok(!/attribute/.test(w.outer()));
  w.attr("attribute", "color");
  this.is("color", w.attr("attribute"));
  w.attr("attribute", null);
  return this.is(null, w.attr("attribute"));
});

new CTest('obj-CWidget-toggleAttr', "`toggleAttr name, [val...]` - переключает атрибут на его следующее значение в списке параметров. Если список не указан - то используется [null, 'disabled']\n\nСм. #toggle, #toggleClass", function() {
  var w;
  w = $('<input>').toggleAttr();
  this.is('disabled', w.attr('disabled'));
  this.is(null, w.toggleAttr().attr('disabled'));
  w.attr('color', 'red');
  w.toggleAttr('color', 'blue', 'green', 'red');
  return this.is('blue', w.attr('color'));
});

new CTest('obj-CWidget-prop', "* `prop name, [val]` - устанавливает, возвращает или удаляет атрибут\n* `prop [name1, ...]` - возвращает объект с значениями указанных атрибутов\n* `prop name, null` - удаляет атрибут\n* `prop {name1: val1 ...}` - множественное присваивание/удаление\n\n'Примечание' - если атрибута нет, то возвращается null\n\nСм. #attr, #css, #addClass", function() {
  var w;
  w = $("<div></div>");
  this.is(void 0, w.prop("property"));
  w.prop("property", "color");
  return this.is("color", w.prop("property"));
});

new CTest('obj-CWidget-toggleProp', "`toggleProp name, [val...]` - переключает атрибут на его следующее значение в списке параметров. Если список не указан - то используется [null, 'disabled']\n\nСм. #toggle, #toggleClass", function() {
  var w;
  w = $('<input type=checkbox>').toggleProp();
  this.is(w.prop('checked'), true);
  this.is(false, w.toggleProp().prop('checked'));
  w.prop('color', 'red');
  w.toggleProp('color', 'blue', 'green', 'red');
  return this.is('blue', w.prop('color'));
});

new CTest('obj-CWidget-addClass', "`addClass class, [timeout], [listen]` - добавляет один или несколько классов\n\nСм. #toggleClass, #removeClass, #hasClass", "<div id=$name></div>\n\n<a href=\"#\" onclick=\"$(this).prev().toggleClass('test-square', 'fast'); return false\">удалить / добавить класс</a>", function() {
  var self, w;
  w = $("<div></div>").addClass("c1 c2");
  this.is(w.element.className, "c1 c2");
  w.addClass(["c3", "c1"]);
  this.is(w.element.className, "c1 c2 c3");
  self = this;
  return this.w().addClass("test-square", "fast", function() {
    self.ok(this.hasClass("test-square"));
    return self.ok(!this.attr('style'));
  });
});

new CTest('obj-CWidget-toggleClass', "`toggleClass classes, [timeout], [listen]` - переключает класс на следующий в списке classes. Если следующий параметр null - то класс удаляется\n\nСм. #toggle, #toggleAttr, #toggleProp", "<div id=$name></div>\n\n<a href=\"#\" onclick=\"$(this).prev().toggleClass('test-square', 'fast'); return false\">удалить / добавить класс</a>", function() {
  var self, w;
  this.count(8);
  w = $('<input class="on">').toggleClass('on off');
  this.ok(w.hasClass('off'));
  this.ok(!w.hasClass('on'));
  w.toggleClass(['on', 'off']);
  this.ok(!w.hasClass('off'));
  this.ok(w.hasClass('on'));
  w.toggleClass(['on', null, 'off']);
  this.ok(!w.hasClass('off'));
  this.ok(!w.hasClass('on'));
  self = this;
  return this.w().toggleClass("test-square", "fast", function() {
    self.ok(this.hasClass("test-square"));
    return self.ok(!this.attr('style'));
  });
});

new CTest('obj-CWidget-show', "`show [timeout], [listen]` - показывает элемент, устанавливая его свойство css _display_ в !''", "<div class=test-square>тест show / hide</div>\n<a id=$name href=\"#\" onclick=\"p=$(this).prev(); if(p.element.style.display == 'none') p.show('fast'); else p.hide('fast'); return false\">скрыть / показать</a>", function() {
  return this.is($('<div style="display: none"></div>').show().css('display'), '');
});

new CTest('obj-CWidget-hide', "`hide [timeout], [listen]` - скрывает элемент, устанавливая его свойство css _display_ в !'none'", function() {
  return this.is($('<div></div>').hide().css('display'), 'none');
});

new CTest('obj-CWidget-vid', "`vid [timeout], [listen]` - показывает элемент, устанавливая его свойство css _visibility_ в ''", "<div class=test-square>тест vid / novid</div>\n<a id=$name href=\"#\" onclick=\"p=$(this).prev(); if(p.element.style.visibility == 'hidden') p.vid('fast'); else p.novid('fast'); return false\">скрыть / показать</a>", function() {
  return this.is($('<div style="visibility: hidden"></div>').vid().css('visibility'), '');
});

new CTest('obj-CWidget-novid', "`novid [timeout], [listen]` - скрывает элемент, устанавливая его свойство css _visibility в !'hidden'", function() {
  return this.is($('<div></div>').novid().css('visibility'), 'hidden');
});

new CTest('obj-CWidget-toggleVid', "`toggleVid [timeout], [listen]` - меняет visibility элемента, устанавливая его свойство css _visibility в !'hidden'", function() {
  this.is($('<div></div>').toggleVid().css('visibility'), 'hidden');
  return this.is($('<div style="visibility:hidden"></div>').toggleVid().css('visibility'), '');
});

new CTest('obj-CWidget-visible', "`visible` - проверяет - является ли элемент видимым", function() {
  this.is($('<div></div>').visible(), false);
  return this.is($('<div></div>').appendTo(/body/).visible(), true);
});

new CTest('obj-CWidget-absolute', "`absolute` - как и pos возвращает {left, top, right, bottom, width, height} элемента относительно верхнего левого угла документа и даже если элемент скрыт", "<div>\n	<div>\n		<div id=\"$name\" style=\"width:10px; height:10px\">show</div>\n	</div>\n</div>", function() {
  var height, p, w, width, _ref;
  w = this.w();
  p = w.up().up();
  this.is(10, w.width());
  this.is(10, w.height());
  p.hide();
  this.is(0, w.width());
  this.is(0, w.height());
  _ref = w.absolute(), height = _ref.height, width = _ref.width;
  this.is(10, width);
  this.is(10, height);
  this.is(0, w.width());
  return this.is(0, w.height());
});

CTest.category("методы расположения на экране");

new CTest('obj-CWidget-vscroll', "- `vscroll` - возвращает позицию горизонтального скролла\n- `vscroll \"bar\"` - возвращает ширину скроллбара\n- `vscroll \"size\"` - возвращает размер скроллбара\n- `vscroll \"inner\"` - возвращает размер скроллбара без padding-а элемента\n- `vscroll \"end\"` - стоит ли скролл в самом конце\n- `vscroll \"begin\"` - стоит ли скролл в самом начале\n- `vscroll val` - устанавливает положение горизонтального скролла в любых единицах: px, pt, in, em, % и т.д.\n\nСм. #hscroll", "<div id=\"$name\" style=\"width:20px; height:20px; overflow: scroll\">scroll</div>", function() {
  var w;
  return w = this.w();
});

new CTest('obj-CWidget-hscroll', "- `hscroll` - возвращает позицию вертикального скролла\n- `hscroll \"bar\"` - возвращает высоту скроллбара\n- `hscroll \"size\"` - возвращает размер скроллбара\n- `hscroll \"inner\"` - возвращает размер скроллбара без padding-а элемента\n- `hscroll \"end\"` - стоит ли скролл в самом конце\n- `hscroll \"begin\"` - стоит ли скролл в самом начале\n- `hscroll val` - устанавливает положение вертикального скролла в любых единицах: px, pt, in, em, % и т.д.\n\nСм. #vscroll", "<div id=\"$name\" style=\"width:20px; height:20px; overflow: scroll\">scroll</div>", function() {
  var w;
  return w = this.w();
});

new CTest('obj-CWidget-viewPos', "`viewPos` - возвращает позицию элемента относительно окна\n\nСм. #pos, #width, #left", "<div id=\"$name\">pos</div>", function() {
  var buttom, height, left, right, top, w, width, _ref;
  w = this.w();
  _ref = w.viewPos(), left = _ref.left, top = _ref.top, right = _ref.right, buttom = _ref.buttom, width = _ref.width, height = _ref.height;
  return this.ok(left);
});

new CTest('obj-CWidget-pos', "`pos` - возвращает позицию элемента в документе\n\nСм. #viewPos, #width, #left", "<div id=\"$name\">pos</div>", function() {
  var buttom, height, left, r, right, top, w, width, _ref;
  w = this.w();
  _ref = w.pos(), left = _ref.left, top = _ref.top, right = _ref.right, buttom = _ref.buttom, width = _ref.width, height = _ref.height;
  r = w.viewPos();
  return this.gt(top, r.top + 1);
});

new CTest('obj-CWidget-left', "`left [val]` - возвразщает/устанавливает смещение элемента по горизонтали в документе\n\nСм. #pos, #width, #top", "<div id=\"$name\">pos</div>", function() {
  var w;
  w = this.w();
  return this.ok(w.left() < w.right());
});

new CTest('obj-CWidget-top', "`top [val]` - возвразщает/устанавливает смещение элемента по вертикали в документе\n\nСм. #pos, #width, #left", "<div id=\"$name\">pos</div>", function() {
  var w;
  w = this.w();
  return this.ok(w.top() < w.bottom());
});

new CTest('obj-CWidget-right', "`right [val], [usePos]` - возвразщает/устанавливает смещение границы элемента по горизонтали в документе\n\n- `right val` - увеличивает `width` элемента до `val`\n- `right val, true` - устанавливает `top` элемента до `val-width`\n\nСм. #pos, #width, #top", "<div id=\"$name\">pos</div>", function() {
  var w;
  w = this.w();
  return this.ok(w.left() < w.right());
});

new CTest('obj-CWidget-bottom', "`bottom [val], [usePos]` - возвразщает/устанавливает смещение границы элемента по горизонтали в документе\n\n- `bottom val` - увеличивает `width` элемента до `val`\n- `bottom val, true` - устанавливает `top` элемента до `val-width`\n\nСм. #pos, #width, #top", "<div id=\"$name\">pos</div>", function() {
  var w;
  w = this.w();
  return this.ok(w.top() < w.bottom());
});

new CTest('obj-CWidget-clientWidth', "`clientWidth` - возвразщает/устанавливает ширину элемента. Если у элемента есть скроллбары, то ширина их не учитывает\n\nСм. #pos, #width, #top", "<div id=\"$name\">pos</div>", function() {
  var w;
  return w = this.w();
});

new CTest('obj-CWidget-width', "`width [width]` - возвращает или устанавливает ширину элемента", ".$name-text {position: absolute}\n.$name-line {background: lavender}", "\n<div id=\"name-outer\" class=\"inline-block\" style=\"border: dashed 1px gray\">\n	<div id=\"$name-scrollbox\" class=\"$name-text\" style=\"margin: 80px 0px 0px 280px\"></div>\n	<div class=$name-text>margin: 40px</div>\n	<div class=$name-text style=\"margin: 20px\">border: 40px</div>\n	<div id=\"$name\" style=\"padding:20px; margin: 20px; overflow:scroll; border: solid 20px red; width:150px; height:150px; background: lavender\">\n		<div class=$name-text style=\"margin: -20px\">padding: 40px</div>\n		<div id=\"$name-inner\" style=\"border: dashed 1px gray; width:200px; height: 200px\">\n			<div style=\"border-right: dashed 1px gray; border-bottom: dashed 1px gray; width:149px; height: 149px; margin: -1px\">\n				150x150<br>in 200x200\n			</div>\n		</div>\n	</div>\n</div>\n\n\n", function() {
  var box, cls_line, ow1, ow2, ow3, w;
  w = this.w().tooltip("hi!");
  box = this.w("scrollbox").html("vscroll-bar: " + w.vscroll("bar") + "px<br>hscroll-bar: " + w.hscroll("bar") + "px<br>hscroll-top: " + w.hscroll() + "px<br>hscroll-size: " + w.hscroll('size') + "px<br>hscroll-inner: " + w.hscroll('inner') + "px");
  cls_line = this.name + '-line';
  ow1 = w.line('right', 0, 600, cls_line, 20, 21);
  ow2 = w.line('right', 1, 600, cls_line, 20, 21);
  ow3 = ow1.line('bottom', 0.97, w.outerWidth() - 20, cls_line).css('margin-top', '10px').arrow('bottom').arrow('top');
  w.wrap("<div>outerHeight<br>" + w.outerHeight() + "px</div>").css('padding', 4).appendTo(w.body()).position(ow3, 'right');
  ow1 = w.line('right', 0, 500, cls_line);
  ow2 = w.line('right', 1, 500, cls_line);
  ow3 = ow1.line('bottom', 0.97, w.offsetWidth() - 22, cls_line).css('margin-top', '10px').arrow('bottom').arrow('top');
  w.wrap("<div>offsetHeight<br>" + w.offsetHeight() + "px</div>").css('padding', 4).appendTo(w.body()).position(ow3, 'right');
  ow1 = w.line('right', 0, 400, cls_line, 0, -20);
  ow2 = w.line('right', 1, 400, cls_line, 0, -20);
  ow3 = ow1.line('bottom', 0.97, w.width() - 22, cls_line).css('margin-top', '10px').arrow('bottom').arrow('top');
  w.wrap("<div>height<br>" + w.height() + "px</div>").css('padding', 4).appendTo(w.body()).position(ow3, 'right');
  ow1 = w.line('right', 0, 300, cls_line, 0, -40);
  ow2 = w.line('right', 1, 300, cls_line, 0, -40);
  ow3 = ow1.line('bottom', 0.97, w.innerWidth() - 22, cls_line).css('margin-top', '10px').arrow('bottom').arrow('top');
  return w.wrap("<div>innerHeight<br>" + w.innerHeight() + "px</div>").css('padding', 4).appendTo(w.body()).position(ow3, 'right');
});

CTest.category("методы событий времени и анимации");

new CTest('obj-CWidget-timeout', "`timeout time, name, args...` - вызывает метод name c аргументами args единожды, через time миллисекунд\n\nСм. #clear, #interval", function() {
  var date, flag, self, w;
  this.count(4);
  self = this;
  flag = 0;
  date = new Date();
  window.Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.realloc = function(n, k) {
      self.is(n, 10);
      self.is(k, 30);
      self.ge(new Date().getTime() - date.getTime(), 30);
      return flag = 1;
    };

    return Ex;

  })(CWidget);
  w = $("<div ctype=Ex></div>").timeout(30, "realloc", 10, 30);
  return this.is(flag, 0);
});

new CTest('obj-CWidget-interval', "`interval time, name, args...` - вызывает метод name c аргументами args через каждые time миллисекунд\n\nСм. #clear, #timeout", function() {
  var counter, self, w;
  this.count(2);
  counter = 0;
  self = this;
  window.Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.realloc = function(n, k) {
      self.is(n, 10);
      if (2 === ++counter) {
        return this.clear("realloc");
      }
    };

    return Ex;

  })(CWidget);
  return w = $("<div ctype=Ex></div>").interval(30, "realloc", 10, 30);
});

new CTest('obj-CWidget-clear', "`clear [name]` - удаляет все установленные #timeout-ом и #interval-ом\n\nСм. #clear, #timeout", function() {
  return this.ok(CRoot.clear);
});

new CTest('obj-CWidget-animate', "`animate param, [timeout], [fps], [listener], [progress]` - изменяет с течением времени заданные css-параметры\n\n- param - объект с параметрами css\n- timeout - интервал в миллисекундах или строка fast=600, slow=200, norm=400 за который происходит анимация. Если не указана - берётся norm\n- fps - частота кадров в секунду с которой будет происходить анимация. По умолчанию - 100. Это значит, что раз в 10 миллисекунд будут изменяться параметры css\n- listener - название метода или функция, которая будет вызвана по звершению. По умолчанию посылается метод onAnimate\n- progress [start, k, progress] - функция или имя метода - запускается на каждом шаге анимации\n\nзначения 'param' должны быть в формате:\n[+=|-=] значение_css [in|out|io] [функция]\n\n- значение_css - конечное значение, если не указаны +=|-=, иначе - значение на которое увеличится текущее. Может быть: цветом\n- in - #CMath.easeIn - ничего не делает\n- out - #CMath.easeOut - искажает функцию так, что она выполняется как бы с конца\n- io - #CMath.easeInOut\n- функция - название функции из CMath: #CMath.linear, #CMath.elastic, #CMath.bounce и т.п.\n\n- `animate \"toggle\", [fn]` - возвращает css-параметры к предыдущим значениям с теми же настройками timeout и fps\n- `animate \"clear\"` - останавливает и очищает очередь анимации\n- `animate \"clear\", fn` - удаляет из очереди анимации указанную функцию\n- `animate \"stop\"` - останавливает очередь анимации\n- `animate \"end\"` - мгновенно завершает текущую анимацию и очищает очередь анимации\n- `animate` - запускает очередь анимации\n- `animate \"active\"` - возвращает выполняющуюся в данный момент функцию анимации\n- `animate \"empty\"` - возвращает *true* или *false* в зависимости от того - пуста очередь анимации объекта или нет\n", ".animate-square {position:absolute; background: orange; border: solid 1px brown; cursor:pointer}", "\n<div id=$name class=animate-square onclick=\"this.widget.animate('toggle')\">margin-left: 100px; margin-top: 50px</div>\n\n<div id=$name-plus class=animate-square><input type=button value=\"влево\" onclick=\"this.parentNode.widget.animate({'margin-left': '-=150pt'})\"> <input type=button value=\"вправо\" onclick=\"this.parentNode.widget.animate({'margin-left': '+=150pt'})\"></div>\n\n<div id=$name-square class=test-square onclick=\"say('fff'); $('#$name-square').swap('#$name-move', 'fast')\">&nbsp;</div>\n<div id=$name-move style='border: solid 1px green' class=test-square onclick=\"$('#$name-square').swap('#$name-move', 'fast')\">&nbsp;</div>\n", function() {
  var self, w;
  this.count(6);
  self = this;
  w = this.w();
  w.animate({
    'margin-left': 100,
    'margin-top': 50,
    'background-color': 'rgba(33,12,45,0.6)',
    color: '#fa6',
    'border-color': 'red'
  }, function() {
    self.is('100px', this.css('margin-left'));
    self.is('50px', this.css('margin-top'));
    self.is('rgba(33, 12, 45, 0.6)', "" + this.rgba('background-color'));
    self.is('#FA6', this.rgba('color').smallhex());
    return self.is('red', this.rgba('border-color').name());
  });
  return this.w("plus").css('margin-left', 10).animate({
    'margin-left': "+=100pt"
  }, 1000, 100, function() {
    return self.is$f(this.pt("10px") + 100, this.pt('margin-left'), 0.01);
  });
});

new CTest('obj-CWidget-morph', "`morph param` - анимирует виджет. В отличие от #animate принимает набор параметров\n\nПараметры:\n- effect - название эффекта из CEffect - расширяет им параметры\n- from - начальные значения для анимации\n- to - конечные значения для анимации\n- easy - in|out|io и/или функция по умолчанию, если не указана в параметре из to\n- timeout - время отпущенное на анимацию в миллисекундах или строка fast=600, slow=200, norm=400 или объект. В последнем случае параметры будут расширены этим объектом\n- fps - частота кадров в секунду\n- css - стили устанавливаются на период анимации, а затем - восстанавливаются\n- save - 1 - from и to будут восстановлены после анимации (по умолчанию), 0 - не будут восстановлены\n- begincss - css устанавливается до начала анимации, после сохранения\n- endcss - css устанавливается после окончания анимации и после восстановления сохранённых стилей\n- queue - очередь параметров для morph, которая будет установлена после поставки в очередь анимаций текущей\n- begin - функция или имя метода - запускается до начала анимации\n- end [param] - функция или имя метода - запускается в конце анимации\n- end1 [param] - функция или имя метода - запускается в конце анимации, после end\n- progress [start, k, progress] - функция или имя метода - запускается на каждом шаге анимации\n\n\nИз progress можно получить созданную для анимации функцию anim через arguments.caller\n\nЕсли стиля из from нет в to, а из to нет в from, то to или from дополняется вычесленным текущим стилем\n\nСм. #animate", "<div class=test-square id=$name onclick=\"$(this).animate('toggle')\"></div>", function() {
  var self;
  this.count(1);
  self = this;
  return this.w().morph({
    save: 0,
    to: {
      'background-color': 'gainsboro'
    },
    end: function() {
      return self.is(this.rgba('background-color').name(), 'gainsboro');
    }
  });
});

new CTest('obj-CWidget-shape', "`shape shape` - добавляет виджет в шейп\n\nШейп - это виджет-обёртка, которая вставляется на место оборачиваемого виджета и содержит как оборачиваемый виджет, так и привязанные к нему виджеты\nПри этом тег оборачиваемого виджета изменяется с li и td на div.\nИ шейп и обёрнутый элемент обслуживаются одним и тем же виджетом, только операции вроде #before работают с верхним элементом, а #content и #append - с нижним.", "", function() {
  var w;
  return w = $("<div></div>");
});

new CTest('obj-CWidget-position', "`position elem, scalex, [scaley], [scaleselfx], [scaleselfy], [addX], [addY]` - абсолютное позиционирование элемента\n\n", "\n#$name-bs, .%name div { position: absolute; width: 10px; height: 10px; border: solid 3px blue; background-color: red; }\n.%name div.after { background-color: green }\n\n#$name-bs {margin-left: 800px; margin-top: -100px}\n", "<div id=$name class=test-square>&nbsp;</div>\n<div id=$name-ts class=test-square>&nbsp;</div>\n\n<div id=$name-bs>&nbsp;</div>\n\n<div class=%name>\n<div id=\"%name-lefttop\">&nbsp;</div>\n</div>\n", function() {
  var bs, main, p, w;
  w = this.w('lefttop');
  main = this.w();
  w.addClass('after').position(main, 'left', 'top');
  w = w.clone(this.name + '-center_top').insertBefore(w).position(main, 'center', 'top');
  this.is$f(w.viewPos().bottom, main.viewPos().top);
  this.is$f((p = w.viewPos()).right - p.left, p.width);
  w.clone(this.name + '-right_top').insertBefore(w).position(main, 'right', 'top');
  w.clone(this.name + '-left_mid').insertBefore(w).position(main, 'left', 'mid');
  w.clone(this.name + '-center_mid').insertBefore(w).position(main, 'center', 'mid');
  w.clone(this.name + '-right_mid').insertBefore(w).position(main, 'right', 'mid');
  w.clone(this.name + '-left_bottom').insertBefore(w).position(main, 'left', 'bottom');
  w.clone(this.name + '-center_bottom').insertBefore(w).position(main, 'center', 'bottom');
  w.clone(this.name + '-right_bottom').insertBefore(w).position(main, 'right', 'bottom');
  (w = w.clone().insertBefore(w).removeClass('after')).position(main, 'left', 'top', 'before', 'before');
  w.clone().insertBefore(w).position(main, 'center', 'top', 'before', 'before');
  w.clone().insertBefore(w).position(main, 'right', 'top', 'before', 'before');
  w.clone().insertBefore(w).position(main, 'left', 'mid', 'before', 'before');
  w.clone().insertBefore(w).position(main, 'center', 'mid', 'before', 'before');
  w.clone().insertBefore(w).position(main, 'right', 'mid', 'before', 'before');
  w.clone().insertBefore(w).position(main, 'left', 'bottom', 'before', 'before');
  w.clone().insertBefore(w).position(main, 'center', 'bottom', 'before', 'before');
  w.clone().insertBefore(w).position(main, 'right', 'bottom', 'before', 'before');
  main = this.w("ts");
  w = w.clone().insertBefore(w).position(main, 'left', 'top', 'before', 'before', -10, -10);
  w.clone().insertBefore(w).position(main, 'center', 'top', 'before', 'before', -10, -10);
  w.clone().insertBefore(w).position(main, 'right', 'top', 'before', 'before', -10, -10);
  w.clone().insertBefore(w).position(main, 'left', 'mid', 'before', 'before', -10, -10);
  w.clone().insertBefore(w).position(main, 'center', 'mid', 'before', 'before', -10, -10);
  w.clone().insertBefore(w).position(main, 'right', 'mid', 'before', 'before', -10, -10);
  w.clone().insertBefore(w).position(main, 'left', 'bottom', 'before', 'before', -10, -10);
  w.clone().insertBefore(w).position(main, 'center', 'bottom', 'before', 'before', -10, -10);
  w.clone().insertBefore(w).position(main, 'right', 'bottom', 'before', 'before', -10, -10);
  w = w.clone().insertBefore(w).addClass('after').position(main, 'left', 'top', 'after', 'after', 10, 10);
  w.clone().insertBefore(w).position(main, 'center', 'top', 'after', 'after', 10, 10);
  w.clone().insertBefore(w).position(main, 'right', 'top', 'after', 'after', 10, 10);
  w.clone().insertBefore(w).position(main, 'left', 'mid', 'after', 'after', 10, 10);
  w.clone().insertBefore(w).position(main, 'center', 'mid', 'after', 'after', 10, 10);
  w.clone().insertBefore(w).position(main, 'right', 'mid', 'after', 'after', 10, 10);
  w.clone().insertBefore(w).position(main, 'left', 'bottom', 'after', 'after', 10, 10);
  w.clone().insertBefore(w).position(main, 'center', 'bottom', 'after', 'after', 10, 10);
  w.clone().insertBefore(w).position(main, 'right', 'bottom', 'after', 'after', 10, 10);
  bs = this.w('bs');
  return main.clone(this.name + '-rs').insertBefore(main).css({
    'margin': 0
  }).position(bs, 'left', 'top', 'after', 'after');
});

new CTest('obj-CWidget-relative', "`relative elem, scalex, [scaley], [scaleselfx], [scaleselfy], [addX], [addY]` - позиционирование элемента относительно элемента в котором он находится\n\nЭлемент перемещается в elem, если он ещё не в нём, и позиционируется путём установки margin-left и margin-top. Ему так же проставляется position: absolute\n", "\n.%name { width:150px; height: 150px; background-color: lavender; border-left: 0; border-right: solid 3px red; border-top: solid 5px red; border-bottom: solid 1px red; font-size: 40pt}\n\n.%name div { position: absolute; width: 10px; height: 10px; border: solid 3px blue; background-color: red; }\n.%name div.after { background-color: green }\n\n#$name-bs {margin-left: 800px; margin-bottom: 30px; font-size: 40pt; background: goldenrod}\n#$name-ts {text-align:center; vertical-align: middle }\n.%name-ts-tab { margin-left: 300px; margin-top: -100px; }\n", "\n<div id=$name class=\"%name\">main\n	<div id=\"%name-lefttop\">&nbsp;</div>\n</div>\n\n<table class=\"$name-ts-tab\">\n<tr><td id=$name-ts class=\"%name\">ts\n</table>\n\n<div id=$name-bs>bs</div>\n", function() {
  var bs, main, main1, rs, w;
  w = this.w('lefttop');
  main1 = main = this.w();
  w.addClass('after').relative(main, 'left', 'top');
  w.clone(this.name + '-center_top').relative(main, 'center', 'top');
  w.clone(this.name + '-right_top').relative(main, 'right', 'top');
  w.clone(this.name + '-left_mid').relative(main, 'left', 'mid');
  w.clone(this.name + '-center_mid').relative(main, 'center', 'mid');
  w.clone(this.name + '-right_mid').relative(main, 'right', 'mid');
  w.clone(this.name + '-left_bottom').relative(main, 'left', 'bottom');
  w.clone(this.name + '-center_bottom').relative(main, 'center', 'bottom');
  w.clone(this.name + '-right_bottom').relative(main, 'right', 'bottom');
  w = w.clone().removeClass('after').relative(main, 'left', 'top', 'before', 'before');
  w.clone().relative(main, 'center', 'top', 'before', 'before');
  w.clone().relative(main, 'right', 'top', 'before', 'before');
  w.clone().relative(main, 'left', 'mid', 'before', 'before');
  w.clone(this.name + '-center_mid_before').relative(main, 'center', 'mid', 'before', 'before', -10);
  w.clone().relative(main, 'right', 'mid', 'before', 'before');
  w.clone().relative(main, 'left', 'bottom', 'before', 'before');
  w.clone().relative(main, 'center', 'bottom', 'before', 'before');
  w.clone().relative(main, 'right', 'bottom', 'before', 'before');
  main = this.w("ts");
  w = w.clone().prependTo(main).relative(main, 'left', 'top', 'before', 'before', -10, -10);
  w.clone().relative(main, 'center', 'top', 'before', 'before', -10, -10);
  w.clone().relative(main, 'right', 'top', 'before', 'before', -10, -10);
  w.clone().relative(main, 'left', 'mid', 'before', 'before', -10, -10);
  w.clone().relative(main, 'center', 'mid', 'before', 'before', -10, -10);
  w.clone().relative(main, 'right', 'mid', 'before', 'before', -10, -10);
  w.clone().relative(main, 'left', 'bottom', 'before', 'before', -10, -10);
  w.clone().relative(main, 'center', 'bottom', 'before', 'before', -10, -10);
  w.clone().relative(main, 'right', 'bottom', 'before', 'before', -10, -10);
  (w = w.clone().addClass('after')).relative(main, 'left', 'top', 'after', 'after', 10, 10);
  w.clone().relative(main, 'center', 'top', 'after', 'after', 10, 10);
  w.clone().relative(main, 'right', 'top', 'after', 'after', 10, 10);
  w.clone().relative(main, 'left', 'mid', 'after', 'after', 10, 10);
  w.clone().relative(main, 'center', 'mid', 'after', 'after', 10, 10);
  w.clone().relative(main, 'right', 'mid', 'after', 'after', 10, 10);
  w.clone().relative(main, 'left', 'bottom', 'after', 'after', 10, 10);
  w.clone().relative(main, 'center', 'bottom', 'after', 'after', 10, 10);
  w.clone().relative(main, 'right', 'bottom', 'after', 'after', 10, 10);
  bs = this.w('bs');
  rs = this.w().clone(this.name + "-rs").css({
    'margin': 0
  }).relative(bs, 'left', 'top', 'after', 'after');
  return rs.down().grep(function() {
    return this.element.nodeType === 3;
  }).text("rs");
});

CTest.category("методы шейпов");

new CTest('obj-CWidget-arrow', "`arrow pos = 'right', scale = 0.5, height = 10, width = 20, scale_corner = 0.5` - добавляет стрелку к блоку\n\n* pos - c какой стороны элемента будет стрелка left|right|top|bottom\n* scale - местонахождение стрелки на указанной стороне - 0.5 - посередине. 0..1\n* height - высота стрелки в px\n* width - ширина основания стрелки (стрелка - треугольник) в px\n* scale_corner - сдвиг указующего угла стрелки - 0..1\n", "\n<div style='position: absolute; margin-left: 150px; width: 100px; height: 100px; background: white; border: solid 1px orange'>123</div>\n<div id=$name class=test-square style=\"background: #0A0A0A\"></div>\n", function() {
  var w;
  w = this.w().css({
    opacity: 0.5,
    'box-shadow': '3px 4px 5px 6px royalblue'
  });
  w.arrow('top', 0.5, 10, 50);
  this.is$f(w._arrow.pos().top, w.pos().top - 10);
  this.is$f(w._arrow.pos().left, w.pos().left + (w.offsetWidth() - 50) * 0.5);
  w._arrow = null;
  w.arrow('bottom', 0.5, 10, 50);
  this.is$f(w._arrow.pos().bottom, w.pos().bottom + 10);
  w._arrow = null;
  w.arrow('left', 0.5, 10, 50);
  this.is$f(w._arrow.pos().left, w.pos().left - 10);
  w._arrow = null;
  w.arrow('right', 1, 10, 50);
  return this.is$f(w._arrow.pos().right, w.pos().right + 10);
});

new CTest('obj-CWidget-line', "line pos = 'right', scale = 0, len = 30, className = '', addx = 0, addy = 0\n\nСоздаёт красную линию из div-а. Линия может быть только вертикальной или горизонтальной. Она сразу вставляется в body и выравнивается на ", "<div id=\"$name\" class=test-square></div>", function() {
  var line;
  line = this.w().line();
  return this.is(line.rgba("background").name(), "red");
});

new CTest('obj-CWidget-edit', "edit opt - делает элемент редактируемым (на самом деле просто выводит над ним input или textarea)\n\nОпции:\n- line - определяет, будет ли элемент редактироваться в одну строку\n- css - дополнительные стили для элемента-редактора\n\nПосылает событие onBeforeEdit до того, как изменит редактируемый элемент. И onEdit после того как изменит.\nДля вставки в элемент данных используется метод dataType\n", "<div id=\"$name\" class=test-square></div>", function() {
  var w;
  this.count(3);
  w = this.w();
  w.onBeforeEdit = (function(_this) {
    return function(edit) {
      edit.val("123");
      return _this.ok(CRoot.contains(edit));
    };
  })(this);
  w.onEdit = (function(_this) {
    return function() {
      return _this.is(w.val(), "123");
    };
  })(this);
  w.edit();
  this.is(w._edit.hasFocus(), true);
  return w.append("<input>").last().focus();
});

CTest.category("методы ajax");

new CTest('obj-CWidget-dataType', "`dataType text` - преобразует text в данные. Используется при загрузке методами #load и #submit", function() {});

new CTest('obj-CWidget-param', "`param` - возвращает параметры для отправки данных виджета на сервер. Используется методами #save и #submit\n\nСм. #dataType", function() {});

new CTest('obj-CWidget-load', "`load [param], [args...]` - загружает данные в виджет посредством ajax-запроса\n\n* param - дополнительные параметры запроса\n* args... - любые аргументы, которые будут переданы в обработчики событий onLoad, onError и onComplete после параметра request\n\nЗагрузку осуществляет #loader. Это отдельный виджет, который служит индикатором (показывает пользователю процесс загрузки).\nПри завершении запроса вызывается метод `onComplete request, args...`. Если запрос вернулся с ошибкой или dataType не смог преобразовать возвращённые данные, то вызывается `onError request, args...`. Иначе - `onLoad request, args...`\n\n'request' - это объект, который содержит поля:\n\n* request - транспорт, обычно экземпляр 'XMLHttpRequest'\n* type - название метода инициализировавшего запрос. В данном случае - load\n* param - параметры запроса в виде объекта\n* customer - виджет инициализировавший загрузку\n* args - дополнительные аргументы, переданные в функцию load\n* message - сообщение об ошибке. Добавляется, только если произошла ошибка\n* exception - исключение приведшее к ошибочке в методе #dataType\n\nurl, по которому будет осуществлён запрос, выбирается следующим образом:\n- из параметра _act, например: `load _act: 'my_path'`. Причём к пути прибавляется начальный \"/\": /my_path\n- из тега action виджета this или виджета loader\n- из атрибута id. Например: `<div id=lod></div>` `CRoot.byId('lod').load()`. Соответственно url = /lod\n- используется location.pathname\n\nСпециальные параметры:\n- _async - должен ли запрос быть асинхронным. На синхронный запрос таймаут не выставляется. По умолчанию все запросы асинхронны\n- _method - указывает метод запроса - POST, GET и т.д. Так же может быть указан через атрибут cmethod или переменную объекта @_method\n\nВремя таймаута, по которому будет разорвано соедининие указано в переменной @_timeout\n\n\nСм. #submit, #save, #erase, #ping, #loader, #loading, #dataType", function() {});

new CTest('obj-CWidget-submit', "`submit [param], [args...]` - обновляет данные в виджете посредством ajax-запроса. Тоесть отправляет данные и загружает. Комбинация #save и #load\n\n* param - дополнительные параметры запроса\n* args... - любые аргументы, которые будут переданы в обработчики событий onLoad, onError и onComplete после параметра request\n\nОстальную информацию см. в #load", function() {});

new CTest('obj-CWidget-save', "`save [param], [args...]` - сохраняет данные в виджете посредством ajax-запроса. Данные для отправки формируются методом #param\n\n* param - дополнительные параметры запроса\n* args... - любые аргументы, которые будут переданы в обработчики событий onLoad, onError и onComplete после параметра request\n\nОстальную информацию см. в #load", function() {});

new CTest('obj-CWidget-erase', "`save [param], [args...]` - удаляет данные связанные с виджетом на сервере посредством ajax-запроса\n\n* param - дополнительные параметры запроса\n* args... - любые аргументы, которые будут переданы в обработчики событий onLoad, onError и onComplete после параметра request\n\nОстальную информацию см. в #load", function() {});

new CTest('obj-CWidget-ping', "`ping [param], [args...]` - просто отправляет ajax-запрос, ничего больше не делая\n\n* param - дополнительные параметры запроса\n* args... - любые аргументы, которые будут переданы в обработчики событий onLoad, onError и onComplete после параметра request\n\nОстальную информацию см. в #load", function() {});

new CTest('obj-CWidget-loader', "`loader` - возвращает виджет-индикатор загрузки\n\nЗагрузчик можно указать установив переменную @_loader, указав атрибут cloader=id_загрузчика. Иначе будет взят загрузчик родителя или его родителя и т.д. Но если ни у кого из родителей нет загрузчика, то в качестве загрузчика будет использован тултип (cм. #tooltip)\n\nСм. #loading, #load", function() {});

new CTest('obj-CWidget-loading', "`loading` - возвращает true, если виджет ожидает завершения ajax-запроса, иначе - false\n\nСм. #dataType", function() {});

CTest.category("методы валидации");

new CTest('obj-CWidget-setValid', "`setValid valid` - устанавливает атрибут cvalid в valid\n\nСм. #valid, #setValid", function() {
  var w;
  w = $("<div>noint</div>");
  this.ok(w.valid());
  w.setValid('int');
  return this.ok(!w.valid());
});

new CTest('obj-CWidget-valid', "`valid` - возвращает true, если значение виджета (val) соответствует выражению валидации. false - если не соответствует и инициализирует событие onInvalid на виджете\n\nСм. #onInvalid, #setValid", function() {
  var w;
  this.ok((w = $("<div cerr='Ошибка' cvalid=int>10</div>")).valid());
  return this.is(w.tooltip(), void 0);
});

new CTest('obj-CWidget-onInvalid', "`onInvalid` - выводит тултип с текстом из атрибута cerr или текстом \"Ошибка - невалидное значение\"\n\nСм. #valid, #setValid", function() {
  var w;
  this.ok(!(w = $("<div cerr='Ошибка' cvalid=int>1.1</div>")).valid());
  return this.is(w.tooltip().text(), 'Ошибка');
});

CTest.category("методы конфигурирования виджета");

new CTest('obj-CWidget-conf', "`conf conf` - расширяет @config\n\nСм. #cconf", function() {
  var Ex, Ex1, ex;
  Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.config = {
      width: 1
    };

    return Ex;

  })(CWidget);
  Ex1 = (function(_super) {
    __extends(Ex1, _super);

    function Ex1() {
      return Ex1.__super__.constructor.apply(this, arguments);
    }

    Ex1.prototype.config = {
      width: 2
    };

    return Ex1;

  })(Ex);
  ex = new Ex1(document.createElement('div'));
  ex.conf({
    width: 3
  });
  this.is(ex.config.width, 3);
  return this.is(ex.constructor.prototype.config.width, 2);
});

new CTest('obj-CWidget-cconf', "`сconf conf` - расширяет @::config\n\nСм. #conf", function() {
  var Ex, Ex1, ex;
  Ex = (function(_super) {
    __extends(Ex, _super);

    function Ex() {
      return Ex.__super__.constructor.apply(this, arguments);
    }

    Ex.prototype.config = {
      width: 1
    };

    return Ex;

  })(CWidget);
  Ex1 = (function(_super) {
    __extends(Ex1, _super);

    function Ex1() {
      return Ex1.__super__.constructor.apply(this, arguments);
    }

    Ex1.prototype.config = {
      width: 2
    };

    return Ex1;

  })(Ex);
  ex = new Ex1(document.createElement('div'));
  ex.cconf({
    width: 3
  });
  this.is(ex.config.width, 3);
  return this.is(ex.constructor.prototype.config.width, 3);
});

CTest.category("Утилиты");

new CTest('key-CTemplate-compile', "`CTemplate.compile html, handlers` - превращает шаблон в функцию\nПолученная функция (`fn dataset, id`) может использоватся затем для формирования текста одиночных форм (передаётся объект) или списков (передаётся список объктов с данными)\n\n- $+ - подставляется id\n- $-name - подставляется id-name\n- $var - подставляются данные с ключём var из dataset\n- #var - подставляются данные с ключём var из dataset и оборачиваются в <span id=id-var></span>\n- $*var - обозначает список. Данные для него должны быть типа Array. Дублирует участок шаблона, ограниченный тегами\n", function() {
  var fn, form, forms, html, r, stash;
  fn = CTemplate.compile("<div id='$+'>\n	#val1\n	#val2\n</div>");
  html = fn({
    val1: 'val-1',
    val2: 'val-2'
  }, 'id-test');
  this.like(html, /val-1/);
  this.like(html, /val-2/);
  this.like(html, /id='id-test'/);
  fn = CTemplate.compile("<div id='$+' ctype=test_class1>\n	#val1\n	<div id=\"$*ls\" ctype=test_class2>\n		#val1\n		<p id=\"$*ls\" ctype=test_class3>\n			#val1\n		</p>\n		#val2\n	</div>\n	#val2\n</div>", forms = {}, form = {});
  html = fn({
    val1: 'val-1',
    val2: 'val-2',
    ls: [
      {
        val1: 'val-1-0',
        val2: 'val-2-0',
        ls: []
      }, {
        val1: 'val-1-1',
        val2: 'val-2-1',
        ls: [
          {
            val1: 'val-1-ls-<0>'
          }
        ]
      }
    ]
  }, 'id-test');
  this["instanceof"](forms[""], Object);
  this["instanceof"](forms["-ls"], Object);
  this["instanceof"](forms["-ls-ls"], Object);
  this.like(html, /val-1/);
  this.like(html, /val-2/);
  this.like(html, /id='id-test' ctype=test_class1/);
  this.like(html, /val-1-0/);
  this.like(html, /val-2-0/);
  this.like(html, /val-1-1/);
  this.like(html, /val-2-1/);
  this.like(html, /val-1-ls-&lt;0&gt;/);
  this.like(html, /"id-test-ls-0-ls" ctype=test_class3/);
  this.like(html, /"id-test-ls-1-ls" ctype=test_class3/);
  this.unlike(html, /id-test-ls-0-ls-0-val1/);
  this.like(html, /id-test-ls-1-ls-0-val1/);
  fn = CTemplate.compile('<table id=$*> <tr id=$*tr><td>$f <table><tr><td>123</table> $x </table>');
  html = fn([
    {
      tr: [
        {
          f: 'f1',
          x: 'x1'
        }, {
          f: 'f2',
          x: 'x2'
        }
      ]
    }, {
      tr: [
        {
          f: 'f3',
          x: 'x3'
        }, {
          f: 'f4',
          x: 'x4'
        }
      ]
    }
  ], 'id_test');
  this.like(html, /f1/);
  this.like(html, /f2/);
  this.like(html, /f3/);
  this.like(html, /f4/);
  this.like(html, /x1/);
  this.like(html, /x2/);
  this.like(html, /x3/);
  this.like(html, /x4/);
  fn = CTemplate.compile('<table id=$* cinit> <!-- who? --> <tr id=$*tr cinit><td>$f <table><tr><td>123</table> $x </table>');
  html = fn([
    {
      tr: [
        {
          f: 'f1',
          x: 'x1'
        }, {
          f: 'f2',
          x: 'x2'
        }
      ]
    }, {
      tr: [
        {
          f: 'f3',
          x: 'x3'
        }, {
          f: 'f4',
          x: 'x4'
        }
      ]
    }
  ], 'id_test');
  this.like(html, /f1/);
  this.like(html, /f2/);
  this.like(html, /f3/);
  this.like(html, /f4/);
  this.like(html, /x1/);
  this.like(html, /x2/);
  this.like(html, /x3/);
  this.like(html, /x4/);
  this.like(html, /<!--/);
  this.like(html, /<!!-- who\? --!>/);
  fn = CTemplate.compile('- \\$x:bool($y:bool("*", \'Да\\n\'), "Нет"):raw(1) -');
  html = fn({
    x: 1
  }, "");
  this.is(html, "- \\Да\n -");
  html = fn({
    x: 0
  }, "");
  this.is(html, "- \\Нет -");
  r = "${x:bool($y:bool('\\''), 10):raw}\n";
  fn = CTemplate.compile(r);
  html = fn({
    x: 1,
    y: 1
  });
  this.is(html, "'\n");
  html = fn({
    x: 0,
    y: 1
  });
  this.is(html, "10\n");
  fn = CTemplate.compile('$xyz:raw:raw');
  html = fn({
    xyz: "<>"
  });
  this.is(html, "<>");
  r = "{% if $x:lt(10) %}\n	{% if $y %}1{% fi %}\n{% elif $y:eq($z) %}\n2\n{% else %}\n3\n{% fi %}";
  fn = CTemplate.compile(r);
  html = fn({
    x: 1,
    y: 1
  });
  this.is(html, "\n\t1\n");
  html = fn({
    x: 10,
    y: 13,
    z: 13
  });
  this.is(html, "\n2\n");
  html = fn({
    x: 10,
    y: 1,
    z: 2
  });
  this.is(html, "\n3\n");
  CTemplate._STASH = stash = {
    stash: '"'
  };
  fn = CTemplate.compile('{% a =%}$%stash:raw{% end %} - $%a $"2":raw(2:raw) $\'2\'');
  html = fn('id');
  this.is(html, " - &quot; 2 2");
  this.is(stash.a, '"');
  fn = CTemplate.compile('<tr tab="$abc"><div id="x1">');
  html = fn({
    abc: 1
  });
  return this.is(html, '<tr tab="1"><div id="x1">');
});

new CTest('key-CDate-format', "`CDate.format format, [date]` - форматирует строку в соответствии с форматом\n\n- format - формат (см. ниже)\n- date - дата. Если не указана, берёт this. Благодаря чему можно расширить Date\n\n- *d* - день месяца\n- *dd* - двухциферный день месяца\n- *ddd* - двухбуквенное обозначение дня недели\n- *dddd* - полное имя дня недели\n- *m* - месяц\n- *mm* - двухциферный месяц\n- *mmm* - трёхбуквенная абревиатура месяца\n- *mmmm* - полное имя месяца\n- *yy* - две последние цифры года\n- *yyyy* - год, четыре цифры\n- *h* - час. 12-часовое время\n- *hh* - час. Две цифры. 12-часовое время\n- *H* - час. 24-часовое время\n- *HH* - час. Две цифры. 24-часовое время\n- *M* - минуты\n- *MM* - минуты. Две цифры\n- *s* - секунды\n- *ss* - секунды. Две цифры\n- *l or L* - милисекунды. l - 3 цифры. L - 2 цифры\n- *t* - сокращённое обозначение \"утра\" или \"вечера\"\n- *tt* - обозначение \"утра\" или \"вечера\"\n- *T* - Uppercase, single-character time marker string: A or P. Uppercase T unlike CF's t to allow for user-specified casing.\n- *TT* - Uppercase, two-character time marker string: AM or PM. Uppercase TT unlike CF's tt to allow for user-specified casing.\n- *Z* - US timezone abbreviation, e.g. EST or MDT. With non-US timezones or in the Opera browser, the GMT/UTC offset is returned, e.g. GMT-0500. No equivalent in CF.\n- *o* - GMT/UTC timezone offset, e.g. -0500 or +0230\n- *S* - порядковый суфикс даты (st, nd, rd, or th). Работает с d\n- *'…' or \"…\"* - последовательности символов\n- *UTC:* - должен стоять в начале формата. Переключает на UTC из UTC/GMT/Zulu. \"UTC:\"-префикс удаляется\n\n[CDate.parse]", function() {
  var date;
  date = new Date('2014/08/12 13:22:15');
  this.is("2014-08-12 13:22:15", CDate.format("yyyy-mm-dd HH:MM:ss", date));
  this.is("Август", CDate.format("mmmm", date));
  return this.is("Вторник 12 Августа", CDate.format("dddd dd mon", date));
});

new CTest('key-CDate-parse', "`CDate.parse format, [date]` - распознаёт строку в соответствии с форматом\n\n[CDate.format]", function() {
  var date;
  date = CDate.parse("yyyy-mm-dd HH:MM:ss", "2013-08-12 13:22:15");
  this.is("2013-08-12 13:22:15", CDate.format("yyyy-mm-dd HH:MM:ss", date));
  date = CDate.parse("dddd dd mon yyyy year h h12 tt M min s sec l msec", "Вторник 12 Августа 2013 года 12 часов утра 1 минута 3 секунды 45 миллисекунд");
  return this.is("2013-08-12 12:01:03.045", CDate.format("yyyy-mm-dd HH:MM:ss.l", date));
});

new CTest('key-CRadix-to', "`CRadix.to n, radix, [sep]` - переводит натуральное число в заданную систему счисления\n\n- n - число\n- radix - основание числа\n- sep - разделитель между цифрами\n", function() {
  this.is("1/0/", CRadix.to(16, 16, "/"));
  this.is("F/F/", CRadix.to(16 * 16 - 1, 16, "/"));
  this.is("9g", CRadix.to(600, 62));
  this.is("G8", CRadix.to(1000, 62));
  return this.is("Щ", CRadix.to(999, 1000));
});

new CTest('key-CRadix-from', "`CRadix.from s, radix` - парсит число в указанной системе счисления\n\n- n - число\n- radix - основание числа\n", function() {
  this.is(16 * 16 - 1, CRadix.from("FF", 16));
  return this.is(10, CRadix.from("A", 16));
});

new CTest('key-CRows-from', "`CRows.from data` - переводит полученные данные из вида {fields: [заголовки столбцов], rows: [[1-я строка], ...]} в [{заголовок1: данные1, ...}, ...]\n\n- data - строка JSON или объект\n", function() {
  var res;
  res = CRows.from({
    fields: ["id", "name", ["user", "id", ["sess", "id"], "name"]],
    rows: [["id1", "name1", [["user.id1", [['user.sess.id1']], "user.name1"], ["user.id2", [['user.sess.id2']], "user.name2"]]]]
  });
  return this.is('[{"id":"id1","name":"name1","user":[{"id":"user.id1","name":"user.name1","sess":[{"id":"user.sess.id1"}]},{"id":"user.id2","name":"user.name2","sess":[{"id":"user.sess.id2"}]}]}]', toJSON(res));
});

new CTest('key-CRows-to', "`CRows.to data` - превращает набор записей в заголовок и набор значений\n\n- data - массив объектов\n", function() {
  var data;
  data = CRows.to([
    {
      id: "id1",
      name: "name1",
      user: [
        {
          sess: [
            {
              id: 'user.sess.id1'
            }
          ],
          id: 'user.id1',
          name: 'user.name1'
        }, {
          id: 'user.id2',
          name: 'user.name2',
          sess: [
            {
              id: 'user.sess.id2'
            }
          ]
        }
      ]
    }
  ]);
  return this.is('{"fields":["id","name",["user",["sess","id"],"id","name"]],"rows":[["id1","name1",[[[["user.sess.id1"]],"user.id1","user.name1"],[[["user.sess.id2"]],"user.id2","user.name2"]]]]}', toJSON(data));
});

new CTest('key-CUrl-from', "`CUrl.from url` - парсит url и возвращает ассоциативный массив c элементами URL", function() {
  var url;
  url = CUrl.from("abc#123");
  this.is(url.pathname, "abc");
  this.is(url.hash, "123");
  url = CUrl.from('http://rubin/');
  this.is(url.protocol, 'http');
  this.is(url.host, 'rubin');
  return this.is(url.pathname, '/');
});

new CTest('key-CUrl-to', "`CUrl.to url_object` - обращает в url", function() {
  this.is("?a=1", CUrl.to({
    search: CParam.to({
      a: 1
    })
  }));
  this.is("//rubin", CUrl.to({
    host: 'rubin'
  }));
  this.is("//rubin/", CUrl.to({
    host: 'rubin',
    pathname: "/"
  }));
  this.is("//rubin/abc", CUrl.to({
    host: 'rubin',
    pathname: "abc"
  }));
  return this.is("//rubin/abc", CUrl.to({
    host: 'rubin',
    pathname: "/abc"
  }));
});

CTest.category("Виджеты");

new CTest('cls-CTemplateWidget', "`CTemplateWidget` - форма-темплейт. Метод `@val` формирует её содержимое через шаблон\n\n- класс c-template указывает, что шаблон находится в теле элемента\n- атрибут cinit указывает, что шаблон находится в комментарии - первой ноде элемента\n- в остальных случаях пробует получить свой шаблон из шаблона parent-ов\n\nСм. #CListWidget, #CFormWidget", function() {
  var w;
  this.is($("<div id=i ctype=template class=c-template>$val1</div>").val({
    val1: 123
  }).html(), '123');
  this.is((w = $("<div id=x ctype=template cinit><!-- #val1 --><span id=x-val1>345</span></div>")).$val1.val(), '345');
  return this.is(w.val({
    val1: 123
  }).$val1.val(), '123');
});

new CTest('cls-CListWidget', "`CListWidget` - темплейт-список. Генерирует на основе своего шаблона последовательность элементов-форм\n\nИмена элементов-форм - порядковые или @data.id\n\nСм. #CTemplateWidget, #CFormWidget", function() {
  var u, w;
  this.is((w = $("<lo id=e ctype=list class=c-template><li id=$+ ctype=form>$val1</li></lo>")).val([
    {
      val1: 1
    }, {
      val1: 2
    }
  ]).html().replace(/['"]/g, ''), '<li id=e-0 ctype=form>1</li><li id=e-1 ctype=form>2</li>');
  this.is(w.val([
    {
      val1: 1,
      id: 5
    }
  ]).html().replace(/['"]/g, ''), '<li id=e-5 ctype=form>1</li>');
  w = $("<lo id=e ctype=list class=c-template><li>t: <div id=$* ctype=list>#val1</div> ;</lo>").val([
    [
      {
        val1: 6
      }
    ]
  ]);
  this.is(w.html().replace(/['"]/g, ''), '<li>t: <div id=e-0 ctype=list><span id=e-0-0-val1>6</span></div> ;</li>');
  this.is((u = w.child(0).child(0)).child(0).val(), '6');
  return this.is(u.val([
    {
      val1: 7
    }
  ]).child(0).val(), '7');
});

new CTest('obj-CSortableWidget-dragover', "`CSortableWidget` - наследует CListWidget", "#%name div { background: blue; border: solid 1px red; color: white; font-waight: bold; width: 400px; height: 20px; text-align: center; text-outline: 40px; margin: 1px }\n\n#%name div.sort { }", "<div id=$name ctype=SortableEx class=\"c-ts\">\n	$text\n</div>", function() {
  window.SortableEx = (function(_super) {
    __extends(SortableEx, _super);

    function SortableEx() {
      return SortableEx.__super__.constructor.apply(this, arguments);
    }

    SortableEx.prototype.onSorted = function(frame, frame_prev_on_start) {
      return frame.animate({
        width: '800px'
      }).animate({
        width: '400px'
      });
    };

    return SortableEx;

  })(CSortableWidget);
  return this.w().update({
    fields: ['text'],
    rows: [[1], [2], [3]]
  });
});

new CTest('obj-CRangeWidget-onCreate', "`onCreate` - создаёт ползунок", ".c-range { cursor: pointer }\n.c-range div { width: 10px; height: 10px; background: red; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50% }\n#%name-h, #%name-v { background: Honeydew }", "\n<div style=\"width: 400px\">\n	<div style='float:right'>\n		<div id=\"$name-h\">&nbsp;</div>\n		<br><br>\n		<div id=\"$name-v\">&nbsp;</div>\n	</div>\n	<div id=$name cview=range style=\"width: 110px; height: 5px; background: orange; margin-left: 50px \"></div>\n	<br><br>\n	<div id=$name-vertical cview=range cvertical=\"1\" style=\"width: 5px; height: 110px; background: royalblue; margin-left: 100px\"></div>\n</div>\n", function() {
  var self;
  self = this;
  this.w().onChange = function() {
    return self.w("h").val(this.val());
  };
  this.w('vertical').onChange = function() {
    return self.w("v").val(this.val());
  };
  this.is(this.w().val(), 0);
  return this.is(this.w().val(10).val(), 10);
});


/*
new CTest 'obj-CSelectWidget-set', """
Устанавливает 
""", """
.c-active { background: pink }
""", """

<div id=$name cview=select>
	<div id=$+ cvalue="$value">$text</div>
</div>

""", ->

	@w().menu.update [{text: '--', value: '' }, {text: 'option 1', value: '1' }, {text: 'option2', value: '2' }, {text: 'option3', value: '3' }]
 */

new CTest('cls-CMonthWidget', "", ".c-othermon {background: #ccc}\n.c-current {background: yellow}\n.c-week {color: red; }", "<table id=$name ctype=\"month\"></table>\n<table id=$name-vertical ctype=\"month\"></table>", function() {
  var w;
  this.w().create(new Date());
  w = this.w('vertical');
  w.conf({
    vertical: true
  });
  return w.create(new Date());
});

new CTest('cls-CCalendarWidget', "`CCalendarWidget` - календарь", css_calendar = ".c-calendar { background: white }\n.c-calendar .c-month { border-collapse: collapse }\n.c-calendar .c-month td { border: solid 1px gray }\n.c-calendar .c-arr {cursor: pointer}\n\n.c-othermon {background: #ccc}\n.c-current {background: yellow}\n.c-week {color: red; }\n\n\n.c-clock {width: 250px; border: solid 1px grey; padding: 2px; background: white }\n.c-clock * {text-align: center}\n.c-clock .c-head { font-size: 32px }\n.c-clock .c-hours, .c-clock .c-minsec { font-size: 12px; width: 100%; border-collapse: collapse; margin-top: 2px }\n.c-clock td { border: solid 1px grey }\n.c-clock .c-current {background: lightblue}\n.c-clock .c-zero {color: red}\n.c-clock .c-apply { text-decoration: none; font-weight: 700; color: royalblue; border: solid 1px grey; display: -moz-inline-stack; display: inline-block }\n.c-clock .c-apply:hover { background: Cornsilk }", "<table id=$name cview=\"calendar\"></table>\n<table id=$name-vertical cview=\"calendar\"></table>\n<input id=$name-input>\n<input id=$name-timeinput>", function() {
  this.w().create(new Date());
  this.w("vertical").month.conf({
    vertical: true
  });
  this.w("vertical").create(new Date);
  this.w("input").element.onclick = function() {
    return CRoot.wrap("<table cview=calendar></table>").input(this.widget);
  };
  return this.w("timeinput").element.onclick = function() {
    return CRoot.wrap("<table cview=calendar></table>").timeInput(this.widget);
  };
});

new CTest('cls-CClockWidget', "`CTimeWidget` - виджет для ввода времени", css_calendar, "<div id=$name cview=\"clock\"></div>", function() {
  return this.w().create(new Date);
});


/*
new CTest 'obj-CSelectableWidget-open', """
""", """
<div id=$name></div>
""", ->


new CTest 'obj-CAutocompliterWidget-open', """
""", """
<div id=$name></div>
""", ->
 */

new CTest('obj-CTooltipWidget-open', "[com]", "\n.c-tip {\n	box-shadow: #666 0px 2px 3px;\n	border: solid 3px red;\n	background: white;\n}\n", "\n<div id=$name class=test-square></div>\n", function() {
  var w;
  w = this.w();
  w.tooltip({
    text: "left center",
    pos: 'left',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "top center",
    pos: 'top'
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "right center",
    pos: 'right',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "bottom center",
    pos: 'bottom',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "left top",
    pos: 'left',
    scale: 'top',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "right top",
    pos: 'right',
    scale: 'top',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "left bottom",
    pos: 'left',
    scale: 'bottom',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "right bottom",
    pos: 'right',
    scale: 'bottom',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "top left",
    pos: 'top',
    scale: 'left',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "top right",
    pos: 'top',
    scale: 'right',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "bottom left",
    pos: 'bottom',
    scale: 'left',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  w._tooltip = null;
  w.tooltip({
    text: "bottom right",
    pos: 'bottom',
    scale: 'right',
    width: 20,
    height: 30
  });
  w.tooltip().open();
  return w._tooltip = null;
});

new CTest('obj-CModalWidget-open', "`open` - открывает модальное окно\n\nСоздаёт события: 'onBeforeOpen' и 'onOpen'\n", "\n<div id=$name style='display:none' ctype=modal>\n	\n	<div id=\"$name-fg\" class=test-square style='height: 2000px; margin: 0; padding-top: 700px'>\n		Ещё одно модальное окно:\n		<input id=$name-bt2 type=button value=\"Открыть\">\n	</div>\n	\n	<div style='float:right'>\n	[x]\n	</div>\n	\n</div>\n\n<input id=$name-bt type=button value=\"open modal\">\n\n<div id=$name-wmodal cview=\"modal\" cargs=\"class=test-square style=margin:0\" style='display:none'>hi! I am modal number 2</div>\n", function() {
  this.w("bt").element.onclick = (function(_this) {
    return function() {
      return _this.w().open();
    };
  })(this);
  return this.w("bt2").element.onclick = (function(_this) {
    return function() {
      return _this.w("wmodal").open();
    };
  })(this);
});

CTest.category("ajax-загрузчики");


/*
new CTest 'obj-CIncludeWidget-include', """
`include url, [param]` - подгружает страницу html в текущий виджет ajax-запросом один раз.
Если фрагмент уже подгружен, то запрашивает только данные и меняет фрагменты (текущий на скрытый). 
Если в полученном html не было `<script cdata>CRoot.byId("id").update( ... )</script>` , то данные запрашиватся не будут.
Меняет url в строке навигации браузера

- url - url по которому будет загружатся страница
- param - параметры запроса, такие же как в #load

Дополнительные параметры:
- _cut - query-выражение для @find. Указавает тег с которого нужно вставлять данные. По умолчанию это #id виджета

""", ->


new CTest 'obj-CMenuWidget-frame_onclick', """
[com]
""", """
	<div id=$name ctype=CMenuWidget>#x</div>
	""", ->
	list = CWidget::byId(@name).update
		fields: ['x'],
		rows: [[1], [2]]
	frame1 = list.byName 0
	frame2 = list.byName 1

	@ok(!frame1.hasClass('c-active'))
	@ok(!frame2.hasClass('c-active'))
	frame1.x.element.click()
	@ok(frame1.hasClass('c-active'))
	@ok(!frame2.hasClass('c-active'))


new CTest 'obj-CStatusLoader-ohComplete', """
[com]
""", """
	<div id=$name ctype=CStatusLoader cview=status></div>
	<div id="use-$name" action="ajax/value.txt" cloader=#{@name}></div>
	""", ->
	@count(3)
	use = CWidget::byId "use-"+@name
	test=this
	use.onComplete = (req) ->
		console.log('req', req)
		test.is(req.type, 'submit')
		test.is(@data, '!value')
		test.is(req.data, '!value')
	
	use.submit()

new CTest 'obj-CModalWidget-show', """
Показывает элемент. Без параметров
""", """
	<div id=$name ctype=modal>
		<div id=$name-fg>Фореграунд</div>
		<div id=$name-bg></div>
	</div>
	<a class="button">Открыть</a>
	""", ->
 */

CTest.main_loop();

//# sourceMappingURL=watch.map
